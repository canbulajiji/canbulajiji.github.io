<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Excel 做线性规划全过程：</title>
    <url>/2020/05/24/Excel%20%E5%81%9A%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>因为学生希望Shecan再演示一次如何运用excel来做线性规划，因此Shecan做了几张gif图片来给大家进行说明：</p>
<a id="more"></a>
<p>Step 1. Load Excel Solver 添加solver加载项</p>
<p><img src="https://img-blog.csdnimg.cn/20200525174935693.gif" alt="在这里插入图片描述"></p>
<p>Step II Fill in the formulas </p>
<p>把目标方程，限制条件，决策变量的公式填入我们之前做好的表中。只需要填一个空，回车，然后直接下拉即可。下拉后可以双击检查一下其他空格是否填好。</p>
<p><img src="https://img-blog.csdnimg.cn/20200525174935487.gif" alt="在这里插入图片描述"></p>
<p>Step III 用excel solver 求解最优解</p>
<p>Data—&gt;Solver—&gt;fill in objective fun/constraint/decision variable—&gt;select LPsolver—&gt;solve</p>
<p><img src="https://img-blog.csdnimg.cn/20200525174937409.gif" alt="在这里插入图片描述"></p>
<p>具体填的公式如下：</p>
<p><img src="C:\Users\Hubu\Pictures\excel.png" alt=""></p>
]]></content>
      <categories>
        <category>Teaching</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>Supply Chain</tag>
      </tags>
  </entry>
  <entry>
    <title>Optimization  in supply chain network design by python</title>
    <url>/2020/05/16/supply%20chain/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>This Blog aims at providing the students <strong>python</strong> version examples of supply chain network design.  The case studies are from the book <em>the supply chain management</em>, written by Sunil Chopra and Peter Meindl. In this blog, I convert the Chapter five examples into python code to show students how the constraint and unconstrained optimization can be applied to the supply chain management. </p>
<hr>
<a id="more"></a>
<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>Network design plays a significant role in supply chain strategy phase. In order to maximize the profit, four decisions have to be made, includes:</p>
<ul>
<li>Facility role</li>
<li>Facility location</li>
<li>Capacity allocation</li>
<li>Market and supply allocation</li>
</ul>
<p>The thumb rule of those decisions is to reduce the cost and improve the responsiveness. Mathematically, network design is a series of constraint and unconstrained optimization problem. To show you how math and economics can be connected and applied in the real industry. I adopt the example from the book <em>supply chain management</em>.</p>
<h3 id="Case-study-I-SunOil-Facility-Allocation"><a href="#Case-study-I-SunOil-Facility-Allocation" class="headerlink" title="Case study I SunOil Facility Allocation"></a>Case study I SunOil Facility Allocation</h3><p>SunOil, a manufacturer of petrochemical products with worldwide sales. Shican, as a supply chain manager, is considering establishing facilities to meet demand. One possibility is to set up a facility in a few of the regions. Shican made an investigation of the following five regions- North American, South American, Europe, Africa, and Asia. The data is collected in the Table 1. Shican has to decide the location of the facility and allocate the demand to minimize the cost.</p>
<ol>
<li>What is the annual demand of each region?</li>
<li>Which part shows us the production/transportation cost?</li>
<li>Which part shows us the fixed cost associated with the capacities?</li>
<li>What is the difference between the variable cost and the fixed cost?</li>
</ol>
<p><img src="C:\Users\Hubu\Desktop\VIX\vix-master\vix-master\notebooks\picture1.png" alt=""></p>
<h4 id="Model-Setup"><a href="#Model-Setup" class="headerlink" title="Model Setup"></a>Model Setup</h4><font color=blue>Objective function</font>
$$
\operatorname{Max} Profit=\sum_{i=1}^{n} f_{i} \cdot y_{i}+\sum_{i=1}^{n} \sum_{i=1}^{m} c_{i, j} \cdot x_{i, j}
$$
<font color=blue>Boundary Conditions</font>

<p>$\sum_{i=1}^{n} x_{i, j}=D_{j} \quad j=1, \ldots m$</p>
<p>$\begin{array}{ll}\sum_{j=1}^{m} x_{i, j} \leq K_{i} \cdot y_{i} &amp; i=1, \ldots n   \end{array}$</p>
<p>$y_{i} \in\{0,1\}$</p>
<h3 id="Case-study-II-GRAVITY-LOCATION-MODELS"><a href="#Case-study-II-GRAVITY-LOCATION-MODELS" class="headerlink" title="Case study II GRAVITY LOCATION MODELS"></a>Case study II GRAVITY LOCATION MODELS</h3><p>Steel Appliances(SA), a manufacturer of high-quality refrigerators and cooking ranges. SA has one assembly factory located near Denver, from which it has supplied the entire United States. Demand has grown rapidly and the CEO of SA has decided to set up another factory to serve its eastern markets. The supply chain manager is asked to find a suitable location for the new factory. Three parts plants located in Buffalo, Boston, Jacksonville, Philadelphia, and New York. The coordinate location, the demand in each market, the required supply from each parts plant, and the shipping cost for each supply source or market are shown in SA.Excel.</p>
<p><img src="https://img-blog.csdnimg.cn/20200515235257285.png" alt="在这里插入图片描述"></p>
<h4 id="Model-Setup-1"><a href="#Model-Setup-1" class="headerlink" title="Model Setup"></a>Model Setup</h4><p><font color=blue>Objective function</font></p>
<script type="math/tex; mode=display">
\operatorname{Min} \mathrm{TC}=\sum_{n=1}^{k} d_{n} D_{n} F_{n}</script><p>with distance: $d_{n}=\sqrt{\left(x-x_{n}\right)^{2}+\left(y-y_{n}\right)^{2}}$</p>
<hr>
<p>Iterative procedure for the gravity model</p>
<ol>
<li><p>For each supply source or market n , evaluate $𝑑_𝑛$;</p>
</li>
<li><p>Obtain a new location $(𝑥’,𝑦’)$ for the facility, where</p>
<script type="math/tex; mode=display">
x^{\prime}=\frac{\sum_{n=1}^{k} \frac{D_{n} F_{n} x_{n}}{d_{n}}}{\sum_{n=1}^{k} \frac{D_{n} F_{n}}{d_{n}}} \quad y^{\prime}=\frac{\sum_{n=1}^{k} \frac{D_{n} F_{n} y_{n}}{d_{n}}}{\sum_{n=1}^{k} \frac{D_{n} F_{n}}{d_{n}}}</script></li>
<li><p>If the new location  $(𝑥’,𝑦’)$ is almost the same as $( 𝑥, y )$ stop</p>
</li>
<li>Otherwise set $( 𝑥, y )=(x’,y’)$ and go to step 1.</li>
</ol>
<hr>
<h3 id="Python-Code"><a href="#Python-Code" class="headerlink" title="Python Code"></a>Python Code</h3><p>Solution with Python can be clone from my Github:</p>
<p><a href="%E2%80%8B%C2%A0https://github.com/canbulajiji/Supply-Chain-Optimization">SC Network Design</a></p>
<p><a href="https://github.com/canbulajiji/Supply-Chain-Optimization" target="_blank" rel="noopener">https://github.com/canbulajiji/Supply-Chain-Optimization</a></p>
<p>The contents of my Repo:</p>
<ol>
<li>Introduction of the optimization in Python. </li>
<li>Market and supply source allocation. Case study I solution.</li>
<li>Gravity Model.  Case study II solution and visualization.</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p> Chopra S, Meindl P, Kalra D V. Supply chain management: strategy, planning, and operation[M]. Boston, MA: Pearson, 2013.</p>
]]></content>
      <categories>
        <category>Teaching</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Supply Chain</tag>
      </tags>
  </entry>
  <entry>
    <title>最优化在供应链网络设计中的应用：基于Python</title>
    <url>/2020/05/16/%E4%BE%9B%E5%BA%94%E9%93%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本博客旨在提供学生<strong>python</strong>版本的供应链网络设计的例子。案例研究来自苏尼尔•乔普拉(Sunil Chopra)和彼得•迈德尔(Peter Meindl)合著的《供应链管理》(The supply chain management)一书。在这篇博客中，我将第五章的例子转换成python代码，向学生展示约束和无约束优化如何应用于供应链管理。<strong>重点</strong>：由于内容较长，这篇博文主要目的是简介案例内容，建模与程序实践请<strong>直接拉到最后</strong>，看Shecan提供的Github链接。</p>
<hr>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>网络设计在供应链战略阶段起着至关重要的作用。经济行为的根本目的是实现利润最大化，而在供应链策略阶段我们需要做出四个决策，包括:</p>
<ul>
<li>工厂的作用</li>
<li>工厂的位置</li>
<li>资金分配</li>
<li>市场及供应源配置</li>
</ul>
<p>这些决策的最终目标是在满足客户需求的条件下尽可能降低成本，以实现利润最大化。从数学上讲，网络设计是一一系列的带约束条件和无约束条件的最优化问题。本博客将向您展示如何将数学和经济学联系起来并应用于实际。这里，采用了《供应链管理》一书中的连个例子。</p>
<h3 id="案例研究-I-SunOil厂商分布"><a href="#案例研究-I-SunOil厂商分布" class="headerlink" title="案例研究 I SunOil厂商分布"></a>案例研究 I SunOil厂商分布</h3><p>SunOil是一家石化产品的制造商，产品销往世界各地。Shecan作为供应链经理，正在考虑建立设施来满足需求。一种可能性是在一些地区建立一个设施。Shecan对北美、南美、欧洲、非洲和亚洲五个地区进行了调查。数据收集在下表中。Shecan必须决定设备的位置并分配需求以使成本最小化。</p>
<ol>
<li><p>每个地区的年需求量是多少?</p>
</li>
<li><p>哪个部分显示了我们的生产/运输成本?</p>
</li>
<li><p>哪一部分向我们展示了与产能相关的固定成本?</p>
</li>
<li><p>可变成本和固定成本的区别是什么?</p>
<p><img src="https://img-blog.csdnimg.cn/20200515235154940.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<h3 id="案例研究-II-重力定位模型"><a href="#案例研究-II-重力定位模型" class="headerlink" title="案例研究 II 重力定位模型"></a>案例研究 II 重力定位模型</h3><p>钢铁电器(SA)是一个高品质冰箱和炉灶的制造商。SA在丹佛附近有一家装配厂，为整个美国供货。需求迅速增长，南非的首席执行官决定建立另一家工厂，以服务其东部市场。供应链经理被要求为新工厂找一个合适的地点。三部分工厂分别位于布法罗，波士顿，杰克逊维尔，费城和纽约。坐标位置、每个市场的需求、每个零件厂所需的供应以及每个供应源或市场的运输成本都显示在下表中。</p>
<p><img src="https://img-blog.csdnimg.cn/20200515235257285.png" alt="在这里插入图片描述"></p>
<p>在shecan的程序中，shecan提供了两种求解思路：</p>
<ol>
<li><p>用scipy.optimization中已经有的非线性最优化模型进行求解；</p>
</li>
<li><p>自己写程序用迭代法进行求解，这个方法的具体求解步骤如下：</p>
<p>1） 初始化工厂位置$(x,y)$，对于每一个供应源和市场，求解距离 $d_n$.</p>
<p>2)   通过不带限制条件最优化的一阶导数条件，更新位置 $(x’,y’)$.</p>
<script type="math/tex; mode=display">
x^{\prime}=\frac{\sum_{n=1}^{k} \frac{D_{n} F_{n} x_{n}}{d_{n}}}{\sum_{n=1}^{k} \frac{D_{n} F_{n}}{d_{n}}} \quad y^{\prime}=\frac{\sum_{n=1}^{k} \frac{D_{n} F_{n} y_{n}}{d_{n}}}{\sum_{n=1}^{k} \frac{D_{n} F_{n}}{d_{n}}}</script><p>3)   如果新的位置$(x’,y’)$ 和原来的位置$(x,y) $差不多，则停止迭代；</p>
<p>4）否则，返回第一步。</p>
</li>
</ol>
<h3 id="Python程序求解以上两个问题"><a href="#Python程序求解以上两个问题" class="headerlink" title="Python程序求解以上两个问题"></a>Python程序求解以上两个问题</h3><p>由于程序比较长，可以从Shecan个人的Github链接获取：</p>
<p><a href="%E2%80%8B%C2%A0https://github.com/canbulajiji/Supply-Chain-Optimization">SC Network Design</a></p>
<p><a href="https://github.com/canbulajiji/Supply-Chain-Optimization" target="_blank" rel="noopener">https://github.com/canbulajiji/Supply-Chain-Optimization</a></p>
<p>如果各位老师/同学有需要，请fork我的repo. 在这个repo中， 我提供了三个文件：</p>
<ol>
<li>用Python处理最优化的简介；</li>
<li>市场和供应商分布研究：案例一的建模与Python求解；</li>
<li>重力模型：案例二的建模与Python求解；</li>
</ol>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>这篇博文针对的是已有Python使用经验的同学，对于没有学过python，而对python感兴趣的同学们，Shecan推荐一个从启蒙到升华很好很高大上很接地气的华东师范大学的公开课：<strong>数据思维与实践</strong>。</p>
<p>Github 链接：</p>
<p><a href="https://github.com/neolee/wop-ecnu-pub" target="_blank" rel="noopener">数据思维与实践教材</a></p>
<p>课程主页 <a href="https://github.com/neolee/wop-ecnu-pub" target="_blank" rel="noopener">https://github.com/neolee/wop-ecnu-pub</a></p>
<p>KFCoding链接：</p>
<p><a href="http://kfcoding.com/editor/08f81fdd4f4b48d985412ce94884c201" target="_blank" rel="noopener">数据思维与实践公开课</a></p>
<p><a href="http://kfcoding.com/editor/08f81fdd4f4b48d985412ce94884c201" target="_blank" rel="noopener">http://kfcoding.com/editor/08f81fdd4f4b48d985412ce94884c201</a></p>
<p>B站链接：</p>
<p><a href="https://www.bilibili.com/video/av95201323" target="_blank" rel="noopener">B站公开课链接</a></p>
<p><a href="https://www.bilibili.com/video/av95201323" target="_blank" rel="noopener">https://www.bilibili.com/video/av95201323</a></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p> Chopra S, Meindl P, Kalra D V. Supply chain management: strategy, planning, and operation[M]. Boston, MA: Pearson, 2013.</p>
]]></content>
      <categories>
        <category>Teaching</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Supply Chain</tag>
      </tags>
  </entry>
  <entry>
    <title>Everything you should know about this blog</title>
    <url>/2020/05/14/Everything-you-should-know-about-this-blog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img-blog.csdnimg.cn/20200514214627829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
  </entry>
  <entry>
    <title>Shecan|Python 在Jupyter Lab 和 cmd 下的版本控制</title>
    <url>/2020/03/23/python%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为何要进行版本控制？对我来说因为运行一些程序发现了版本不兼容的问题，特别是运行一些开源的软件。所以记下来自己控制版本的过程，避免以后重复搜索，浪费时间。</p>
<a id="more"></a>
<ol>
<li><h6 id="cmd-中的版本控制"><a href="#cmd-中的版本控制" class="headerlink" title="cmd 中的版本控制"></a>cmd 中的版本控制</h6><p>需求：每次在cmd中运行 python 的时候启动 python 3.8， 每次在cmd中运行python2的时候启动 python 2.7, 输入 python3 的时候运行 python 3.8. 如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200322202943200.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>第三个python使我之前装的anaconda 3带的版本。</p>
<p>实现以上效果的具体配置如下：</p>
<p>Step 1. Install Python 3.8 and Python 2.7 from <a href="https://www.python.org/downloads/，use" target="_blank" rel="noopener">https://www.python.org/downloads/，use</a> all the default settings. 安装过程中 <strong>注意不要勾选加入到path</strong>, 需要手动加入。或者喜欢anaconda的同学可以从这个网站下载 <a href="https://www.anaconda.com/distribution/，配置方法类似。" target="_blank" rel="noopener">https://www.anaconda.com/distribution/，配置方法类似。</a></p>
<p>Step 2. Find the destination directory of your python files and change the name as below:</p>
<p>找到Python 2.7 的安装目录，把 python 改成  python2。找到Python 3.8 的安装目录，把python 改成 python3 如图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200322203112114.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/2020032220321681.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>   Step 3. 把 Python 3.7 和 python 2.7 加入到环境变量，如图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200322203244966.PNG#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><h6 id="Version-Control-in-Jupyter-lab"><a href="#Version-Control-in-Jupyter-lab" class="headerlink" title="Version Control in Jupyter lab."></a>Version Control in Jupyter lab.</h6><p>需求：如图所示，在Jupyter lab中可以随意切换版本。</p>
<p><img src="https://img-blog.csdnimg.cn/2020032220332038.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>或在运行某一个程序时，也可以随时切换Kernel.</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200322203424793.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>   可以看出R也是可以加入kernel的，这是我以前配置的，但对R来说还是Rstudio比较习惯，配置好了也没用过，所以大家有需要可以自行搜索一下。</p>
<p>   如果是anaconda的用户，在 cmd 中连续输入以下的命令即可</p>
   <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">conda create <span class="literal">-n</span> py27 python=<span class="number">2.7</span></span><br><span class="line">conda activate py27</span><br><span class="line">conda install notebook ipykernel</span><br><span class="line">ipython kernel install -<span class="literal">-user</span></span><br></pre></td></tr></table></figure>
<p>   如果不用 conda, 可以用以下的命令</p>
   <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python2 <span class="literal">-m</span> pip install ipykernel</span><br><span class="line"></span><br><span class="line">python2 <span class="literal">-m</span> ipykernel install -<span class="literal">-user</span></span><br></pre></td></tr></table></figure>
<p>​       参考链接：<a href="https://stackoverflow.com/questions/30492623/using-both-python-2-x-and-python-3-x-in-ipython-notebook" target="_blank" rel="noopener">https://stackoverflow.com/questions/30492623/using-both-python-2-x-and-python-3-x-in-ipython-notebook</a></p>
]]></content>
      <categories>
        <category>Coding Tips</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Shecan|BAW美式期权定价半解析解</title>
    <url>/2020/02/21/BAW%E7%BE%8E%E5%BC%8F%E6%9C%9F%E6%9D%83%E5%AE%9A%E4%BB%B7%E5%8D%8A%E8%A7%A3%E6%9E%90%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BAW美式期权定价半解析解"><a href="#BAW美式期权定价半解析解" class="headerlink" title="BAW美式期权定价半解析解"></a>BAW美式期权定价半解析解</h1><p>参考文献：G. Barone-Adesi &amp; R. E. Whaley, Efficient Analytic Approximation of  American Option Values, The Journal of Finance, No 2 (June 1987), 301-320 </p>
<p>本文详细介绍了BAW模型的基本思想和推导过程，并给出了相应程序的调用方法~<br><a id="more"></a><br>基本思想：美式期权不同于欧式期权之处在于，美式期权可以在到期日之前随时执行，因而美式期权的价值高于欧式期权。美式期权价值高于欧式期权的部分叫做美式期权溢价$\epsilon_c$，如下式所示：</p>
<script type="math/tex; mode=display">
\epsilon_c\left( S , T \right) = C \left( S , T \right) -c \left( S , T \right) ,</script><p>其中$C \left( S , T \right)$表示美式看涨期权的价值；$c \left( S , T \right)$表示欧式看涨期权的价值。</p>
<p>根据Feynman_Kac定理，在无套利假设条件下，欧式期权价值和美式期权价值满足椭圆的偏微分方程，因而，风险溢价也应该满足以下的相同形式的椭圆偏微分方程：</p>
<script type="math/tex; mode=display">
1 / 2 \sigma^{2} S^{2} \varepsilon_{S S}-r \varepsilon+b S \varepsilon_{S}+\varepsilon_{t}=0\tag{1}</script><p>做如下的变量替换：</p>
<p>$\tau = T -t$ 代表距离到期日T的时间；</p>
<p>$M=2 r / \sigma^{2} \text { 和 } N=2 b / \sigma^{2}$</p>
<p>则式（1）可以重写为</p>
<script type="math/tex; mode=display">
S^{2} \varepsilon_{S S}-M_{e}+N S e_{S}-(M / r)\varepsilon_{\tau}=0\tag{2}</script><p>定义美式期权的提前行权溢价满足如下的形式：</p>
<script type="math/tex; mode=display">
\epsilon_c(S, K)=K(\tau) f(S, K)</script><p>其中$K \left( T \right) = 1 - e ^ { - r \tau} ,$ 则(2)式可以重写为</p>
<script type="math/tex; mode=display">
S^{2} f s s+N S f_{s}-(M / K) f-(1-K) M f_{K}=0\tag{3}</script><p>敲黑板！！！BAW方法为何是半解析解，就在于我们要对式（3）进行简化，把最后一项省略掉，式（3）就可以变成一个二次常微分方程。那么最后一项为何可以省略掉呢？当商品期权距离到期日时间非常短（T=0）的时候，$f_{K}$接近于0，即执行价格对风险溢价几乎没影响。当商品期权距离到期日的时间非常长（$\tau=\infin$）的时候，K=1则1-K=0。因而，$f$可以通过近似求解以下的表达式得到：</p>
<script type="math/tex; mode=display">
S^{2} f s s+N S f_{s}-(M / K) f=0</script><p>假设$f=a S^{q}$，代入上式，可以得到两个特征根(M/K为正)：</p>
<script type="math/tex; mode=display">
q _ {1} = - \left( N - 1 \right) - \frac{\sqrt { \left( N - 1 \right) ^ { 2 } + 4 M / K }}{2}<0</script><script type="math/tex; mode=display">
q _ {2} = - \left( N - 1 \right) + \frac{\sqrt { \left( N - 1 \right) ^ { 2 } + 4 M / K }}{2}>0</script><p>则有通解：</p>
<script type="math/tex; mode=display">
f \left( S \right) = a _ { 1 } S ^{ q _ { 1 } } + a _ { 2 } S ^{ q_2 } ,</script><p>现在的问题是如何确定参数$a_1$和$a_2$。这个问题要追溯到美式看涨期权的边值条件</p>
<script type="math/tex; mode=display">
\frac{\partial C}{\partial S}(S^*,\tau)=1\tag{B1}</script><script type="math/tex; mode=display">
C(0,\tau)=0\tag{B2}</script><script type="math/tex; mode=display">
C(S^*,\tau)=S^*-K\tag{B3}</script><p>由（B2）:$C(0,\tau)=c(0,\tau)+K(\tau)f(0)=0$, 可以推出 $f(0)=0$，因而$f(S)=a _ { 2 } S ^{ q_2 }(q_1&lt;0)$。</p>
<p>由（B1）：$\frac{\partial C}{\partial S}(S^<em>,\tau)=\frac{\partial c}{\partial S}(S^</em>,\tau)+K(\tau)\frac{\partial f}{\partial S}$ 可以推导出</p>
<script type="math/tex; mode=display">
1=e^{(b-r) \tau} \mathrm{~N}\left[d_{1}\left(S^{*}\right)\right]+K q_{2} a_{2} S^{* q_{2}-1}</script><p>这里用到了欧式期权的BS公式：</p>
<script type="math/tex; mode=display">
c(S, T)=S e^{(b-r) T} \mathrm{~N}\left(d_{1}\right)-X e^{-r T} \mathrm{~N}\left(d_{2}\right)</script><p>其中 $d_{1}=\left[\ln (S / X)+\left(b+0.5 \sigma^{2}\right) T\right] / \sigma \sqrt{T}, d_{2}=d_{1}-\sigma \sqrt{T}$。</p>
<p>由此，可以求解出 </p>
<script type="math/tex; mode=display">
a_{2}=\left\{1-e^{(b-r) \tau} \mathrm{~N}\left[d_{1}\left(S^{*}\right)\right]\right\} / K q_{2} S^{* q_{2}-1}</script><p>由（B3）可以求解出最优执行边界满足以下的表达式</p>
<script type="math/tex; mode=display">
S^{*}-X=c\left(S^{*}, \tau\right)+\left\{1-e^{(b-r) \tau} \mathrm{~N}\left[d_{1}\left(S^{*}\right)\right]\right\} S^{*} / q_{2}</script><p>综上所述，美式看涨期权的解析公式如下所示：</p>
<script type="math/tex; mode=display">
\begin{array}{ll}
C(S, \tau)=c(S, \tau)+A_{2}\left(S / S^{*}\right)^{q_{2}}, & \text { when } S<S^{*} \\
C(S, \tau)=S-K, & \text { when } S \geq S^{*}
\end{array}</script><p>其中 $A_{2}=\left(S^{<em>} / q_{2}\right)\left\{1-e^{(b-r) T} \mathrm{~N}\left[d_{1}\left(S^{</em>}\right)\right]\right\}$。</p>
<p>美式看跌期权与看涨期权的求解套路差不多：</p>
<script type="math/tex; mode=display">
\epsilon_p\left( S , T \right) = P \left( S , T \right) -p \left( S , T \right)</script><p>区别在于边界条件不同</p>
<script type="math/tex; mode=display">
\frac{\partial P}{\partial S}(S^*,\tau)=-1\tag{B1}</script><script type="math/tex; mode=display">
P(\infin,\tau)=0\tag{B2}</script><script type="math/tex; mode=display">
P(S^*,\tau)=K-S^*\tag{B3}</script><p>python程序实现：参考<a href="https://gist.github.com/rwev/4694f898ab972d402e07816a9f3fbd93" target="_blank" rel="noopener">Python implementation of the Barone-Adesi And Whaley model for the valuation of American options and their greeks. · GitHub</a></p>
<p>调用实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> BAW <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">Stock = []</span><br><span class="line">Put_American = []</span><br><span class="line">Put_European = []</span><br><span class="line">Expir = []</span><br><span class="line">K = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> S <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">151</span>,<span class="number">10</span>):</span><br><span class="line">    Stock.append(S)</span><br><span class="line">    Expir.append(max(K-S,<span class="number">0</span>))</span><br><span class="line">    put_American = getValue(<span class="string">'American'</span>, <span class="string">'Value'</span>, <span class="string">'Put'</span>, S, K, <span class="number">5</span>, <span class="number">0.03</span>, <span class="number">0.02</span>,<span class="number">0.5</span>)</span><br><span class="line">    put_European = getValue(<span class="string">'European'</span>, <span class="string">'Value'</span>, <span class="string">'Put'</span>, S, K, <span class="number">5</span>, <span class="number">0.03</span>, <span class="number">0.02</span>,<span class="number">0.5</span>)</span><br><span class="line">    Put_American.append(put_American)</span><br><span class="line">    Put_European.append(put_European)</span><br><span class="line">    </span><br><span class="line">plt.plot(Stock, Put_American,linewidth=<span class="number">0.5</span>,label=<span class="string">'American Option Value'</span>)</span><br><span class="line">plt.plot(Stock, Put_European,<span class="string">'r-.'</span>,linewidth=<span class="number">0.5</span>,label=<span class="string">'European Option Value'</span>)</span><br><span class="line">plt.plot(Stock, Expir, <span class="string">'g--'</span>,linewidth=<span class="number">0.5</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2021041820363043.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="BAW"></p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Shecan|CIR过程蒙特卡洛模拟</title>
    <url>/2020/02/21/CIR%E8%BF%87%E7%A8%8B%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CIR过程蒙特卡洛模拟"><a href="#CIR过程蒙特卡洛模拟" class="headerlink" title="CIR过程蒙特卡洛模拟"></a>CIR过程蒙特卡洛模拟</h1><p>众所周知，利率是随着时间的变化而随机变化的，本文简要说明了两种常用的随机利率过程，并基于Python用蒙特卡洛的方法模拟出随机利率过程。</p>
<p>(未完待续 ……)<br><a id="more"></a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>最常用的随机利率模型包括：OU 过程和 CIR 过程：</p>
<ul>
<li>The OU process:</li>
</ul>
<script type="math/tex; mode=display">
d r_{t}=\alpha\left(\mu-r_{t}\right) d t+\sigma d W_{t}\tag{1}</script><ul>
<li>The CIR process:</li>
</ul>
<script type="math/tex; mode=display">
d r_{t}=\alpha\left(\mu-r_{t}\right) d t+\sigma \sqrt{r_{t}} d W_{t}\tag{2}</script><p>where $\mu$ 是均值回归的水平 and $\alpha$ 是均值回归的速度。</p>
<p>利率虽然是随机的，但不会长久偏离均值水平，因而是均值回归的。OU 过程服从正态分布，而 CIR 过程服从一个非中心的卡方分布（具体可以看维基上的说明）。CIR 过程优于OU过程之处在于， 可以保证利率的非负性</p>
<h2 id="Monte-Carlo-Simulation"><a href="#Monte-Carlo-Simulation" class="headerlink" title="Monte Carlo Simulation"></a>Monte Carlo Simulation</h2><p>对于以上两个随机过程的离散，通常有两种方法： <strong>Euler–Maruyama Method</strong> and the <strong>Milstein Method</strong>。和一般的不带随机变量的差分相似，两种方法的区别在于在不同的地方对泰勒展开公式进行截断，然而由于随机项的引入，我们需要用Ito-Taylor对其进行展开（具体的推导，我找到的最清楚（读得懂）的证明即参考文献中的’Ito Taylor Expansion’）。</p>
<script type="math/tex; mode=display">
X\left(t_{i+1}\right)=X\left(t_{i}\right)+a\left[X\left(t_{i}\right)\right] \Delta t+b\left[X\left(t_{i}\right)\right] \Delta W_{i}+\frac{1}{2} b\left[X\left(t_{i}\right)\right] b^{\prime}\left[X\left(t_{i}\right)\right]\left[\left(\Delta W_{i}\right)^{2}-\Delta t\right]+\mathcal{O}(\Delta t)</script><p>如上所示， Euler-Maruyama 是对上式的一阶截断， 而 Milstein 是对上式的二阶截断。这里的$\mathcal{O}$ 表示剩余的项是</p>
<p>$\Delta t$ 的高阶项。</p>
<p>因而，我们有以下的两个离散表达式：</p>
<p>Specifically, for the CIR process, we have $a[r] = \alpha(\mu - r)$, $b[r]=\sigma\sqrt{r}$, and $b’[r]=\frac{1}{2}\frac{\sigma}{\sqrt{r}}$.</p>
<ul>
<li>The Euler-Maruyama Method:</li>
</ul>
<script type="math/tex; mode=display">
r_{j}=r_{j-1}+\alpha\left(\mu - r_{j-1}\right) \Delta t+\sigma\sqrt{r_{j-1}}\Delta W_j, \quad j=1,2, \ldots, L</script><p>where $\Delta W_j = \sqrt{\Delta t}N(1,0)$.</p>
<ul>
<li>The Milstein Method:</li>
</ul>
<script type="math/tex; mode=display">
r_{j}=r_{j-1}+\alpha\left(\mu - r_{j-1}\right) \Delta t+\sigma\sqrt{r_{j-1}}\Delta W_j+\frac{\sigma^2}{2}[(\Delta W_j)^2-\Delta t], \quad j=1,2, \ldots, L</script><p>The weak and strong convergence rate of Euler-Maruyama are $\mathcal{}$$\mathcal{O}(\Delta t)$. The Milstein scheme has the same weak convergence but better strong convergence rate of $\mathcal{O}(\sqrt{\Delta t)}$. The detail definition of the weak and the strong convergence rate refer to <em>Higham (2001).</em> （这篇文章是我一个师兄推荐给我的，我学习蒙特卡洛模拟也是从这篇文章开始的，后来有个刚读博士的泰国美女询问我如何做随机过程的蒙特卡洛模拟时，我也把这篇文章推荐给了她，分享使我们快乐。）</p>
<h2 id="Python-Code"><a href="#Python-Code" class="headerlink" title="Python Code"></a>Python Code</h2><p>因为我觉得以后有时间可以在这个问题上玩出朵花来，所以我先写了一个类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Wed Feb 26 22:42:55 2020</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Shecan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">please save the file as CIR.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CIR</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, alpha, mu, sigma, r0)</span>:</span></span><br><span class="line">         self.alpha = alpha <span class="comment"># mean-reverted speed</span></span><br><span class="line">         self.mu = mu <span class="comment"># mean-reverted level</span></span><br><span class="line">         self.sigma = sigma <span class="comment"># vol of interest rate</span></span><br><span class="line">         self.r0 = r0 <span class="comment"># initial interest rate</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Euler</span><span class="params">(self,t_init,t_end,dt)</span>:</span></span><br><span class="line">        np.random.seed(<span class="number">5</span>)</span><br><span class="line">        ts = np.arange(t_init, t_end, dt)</span><br><span class="line">        dW = np.random.normal(loc=<span class="number">0.0</span>, scale=np.sqrt(dt),size = ts.size)</span><br><span class="line">        r = []</span><br><span class="line">        r.append(self.r0)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, ts.size):</span><br><span class="line">            r.append(r[i<span class="number">-1</span>] + self.alpha*(self.mu-r[i<span class="number">-1</span>])*dt </span><br><span class="line">                     + self.sigma*np.sqrt(r[i<span class="number">-1</span>])*dW[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Milstein</span><span class="params">(self,t_init,t_end,dt)</span>:</span></span><br><span class="line">        np.random.seed(<span class="number">5</span>)</span><br><span class="line">        ts = np.arange(t_init, t_end, dt)</span><br><span class="line">        dW = np.random.normal(loc=<span class="number">0.0</span>, scale=np.sqrt(dt),size = ts.size)</span><br><span class="line">        r = []</span><br><span class="line">        r.append(self.r0)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, ts.size):</span><br><span class="line">            dw = dW[i<span class="number">-1</span>]</span><br><span class="line">            r.append(r[i<span class="number">-1</span>] + self.alpha*(self.mu-r[i<span class="number">-1</span>])*dt </span><br><span class="line">                     + self.sigma*np.sqrt(r[i<span class="number">-1</span>])*dw + </span><br><span class="line">                     (self.sigma**<span class="number">2</span>/<span class="number">2</span>)*(dw**<span class="number">2</span> - dt))</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>然后我们在 Jupyter notebook中调用以上的类, </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> CIR <span class="keyword">import</span> CIR <span class="comment"># from the module CIR load our class-file CIR</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># assume mean-reverted speed = 1, mean-reverted level = 0.05, vol of interest rate = 0.05, initial interest rate = 0.05, and pass to an object named C </span></span><br><span class="line">C = CIR(<span class="number">1</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0.05</span>)</span><br><span class="line"><span class="comment"># For Euler method</span></span><br><span class="line">r = C.Euler(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.001</span>) <span class="comment"># start time = 0, end time = 1, dt = 0.01</span></span><br><span class="line"><span class="comment"># For Milstern method</span></span><br><span class="line">r1 = C.Milstein(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.001</span>)</span><br><span class="line"><span class="comment"># Plot and compare</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">l1,=plt.plot(r)</span><br><span class="line">l2,=plt.plot(r1,<span class="string">'b*'</span>,markersize=<span class="number">4</span>)</span><br><span class="line">plt.ylabel(<span class="string">'interest rate r'</span>,fontsize = <span class="number">20</span>)</span><br><span class="line">plt.legend(handles=[l1, l2], labels=[<span class="string">'Euler'</span>, <span class="string">'Milstein'</span>], fontsize = <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>Visualizing the results:</p>
<p><img src="https://img-blog.csdnimg.cn/20200303225854819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70" alt="Monte Carlo Simulation"></p>
<h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p>CIR Modeling of Interest Rates</p>
<p><a href="http://lnu.diva-portal.org/smash/get/diva2:1270329/FULLTEXT01.pdf" target="_blank" rel="noopener">http://lnu.diva-portal.org/smash/get/diva2:1270329/FULLTEXT01.pdf</a></p>
<p>Enlightened reading material</p>
<p><em>Higham, D. J. (2001). An algorithmic introduction to numerical simulation of stochastic differential equations. SIAM review, 43(3), 525-546.</em></p>
<p>Ito-Taylor Expansion</p>
<p><a href="https://www.math.nyu.edu/~cai/Courses/Derivatives/compfin_lecture_5.pdf" target="_blank" rel="noopener">https://www.math.nyu.edu/~cai/Courses/Derivatives/compfin_lecture_5.pdf</a></p>
<p>结束语：我做笔记博客主要有三个目的：1. 在疫情长假期间，闲下来有时间思考人生（睡觉），深刻意识到自己一直在追求一些浮名薄利，一味想高屋建瓴导致一事无成，却忽略了最根本的积累，因而通过博客逼迫自己把每一个小的问题搞清楚并记录下来。2. 虽然生活和事业收获了很多的帮助，但是科研和学习主要靠自己摸索（仰视巨人的肩膀然后脑补），难免有一些异想天开的不足，希望各路大神路过能留下足迹，帮我纠正，让我进步。3. 希望我的行为能帮助到同行人，也算是一点贡献，不枉此生。</p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>Weibull Distribution_MLE_with_Newton_Ranpson_Method</title>
    <url>/2020/02/21/Distribution-MLE-with-Newton-Ranpson-Method/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Censored-Weibull-Distribution-最大似然估计-（结合牛顿法求解）"><a href="#Censored-Weibull-Distribution-最大似然估计-（结合牛顿法求解）" class="headerlink" title="Censored Weibull Distribution 最大似然估计 （结合牛顿法求解）"></a>Censored Weibull Distribution 最大似然估计 （结合牛顿法求解）</h1><p><em>前言：写这篇博客是因为我前几天偶然读到一篇很有意思的文章， 然后想用自己的实验数据测试一下其分布情况，本以外是一个很简单的工作，但再简单的工作也需要不断的更新学习。在学习过程中，我发现已经有很多博文详述了Weibull分布的应用和意义，然而对于如何进行参数估计的问题，却缺乏更加详细的记录文档。于是无聊而又不务正业的Shecan稍微探索了一下，并把笔记分享给大家。如有错误或者疑问，请给Shecan留言。</em></p>
<a id="more"></a>
<p>Weibull 分布函数 CDF：</p>
<script type="math/tex; mode=display">
F(x) = 1 - e^{-(\frac{x}{\beta})^{\alpha}}\tag{1}</script><p>这里 $\beta$ 表示 Scale Parameter, $\alpha$ 表示 Shape Parameter。</p>
<p>分布密度 PDF：</p>
<script type="math/tex; mode=display">
f\left( x\right) =\frac {\alpha } {x}\gamma ^{\alpha }e^{-\gamma ^{\alpha}}\tag{2}</script><p>其中 </p>
<script type="math/tex; mode=display">
\gamma = \frac{x}{\beta}</script><p>censored 似然函数的定义：</p>
<script type="math/tex; mode=display">
L=\prod _{i=1}^{n}\left( f\left( x_i\right) \right) ^{\delta_i}\left( 1-F\left( x_{i}\right) \right) ^{1-\delta_{i}}\tag{3}</script><p>其中</p>
<script type="math/tex; mode=display">
\delta _{i}=\begin{cases} 1,\,x\leq threshold\\ 0,\,x>threshold\end{cases}</script><p>把（1），（2）带入（3）两边求对数，并简化求得对数似然函数：</p>
<script type="math/tex; mode=display">
1og_L=\sum _{i=1}^{n}\left( - \gamma _{i}^{\alpha }+\delta_{i}\alpha ln\gamma _{i}+\delta\ln \frac {\alpha } {x_{i}}\right)\tag{4}</script><p>其中$\alpha$，$\beta$, 可以通过最大化似然函数求得，对（4）求一阶导数</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^{n}\gamma_i^\alpha-\delta_i=0,\tag{5}\\
\sum _{i=1}^{n}\left( -\gamma _{i}^{\alpha }\ln \gamma _{i}+\delta_i\ln \gamma _{i}+\frac {\delta_i} {\alpha }\right) =0.\tag{6}
\end{align}</script><p>（5），（6）是关于$\alpha,\,\beta$ 的外生解，无法求出其解析解，因而需要求解以上两个非线性方程组的数值解。求解非线性方程组数值解的方法有很多，比如非线性最小二乘法，Broyden方法等等，但是我们遵循简单即有效的原则，尝试最为简单的Newton-Rapson解的搜索方法。首先，简化（5）得</p>
<script type="math/tex; mode=display">
\beta =\left( \frac {\sum_{i}^{n}x_{i}^{\alpha }} {\sum_{i}^{n}\delta_{i}}\right) ^{\frac {1} {\alpha }}\tag{7}</script><p>因此，我们只需要通过（6）求解 $\alpha$, 假设</p>
<script type="math/tex; mode=display">
h(\alpha)=\sum _{i=1}^{n}\left( -\gamma _{i}^{\alpha }\ln \gamma _{i}+\delta_i\ln \gamma _{i}+\frac {\delta_i} {\alpha }\right)\tag{8}</script><p>其中</p>
<script type="math/tex; mode=display">
\gamma _{i}=\frac {x_{i}} {\beta }=x_i\left( \frac {\sum x_{i}^{\alpha}}{n}\right)^{-\frac {1} {\alpha }}</script><p>and</p>
<script type="math/tex; mode=display">
\begin{align}
\gamma _{i}^{\alpha }&=x_{i}^{\alpha}\cdot \frac {n} {\sum x_{i}^\alpha} \tag{9}\\
\ln \gamma _{i}&=\ln x_i-\frac {1} {\alpha }\cdot \frac {\sum x_{i}^{\alpha }} {n} \tag{10}
\end{align}</script><p>这里的 $n=\sum \delta_i$ 代表 failed number。</p>
<p>（9）和 （10）代入（8），即得</p>
<script type="math/tex; mode=display">
h\left( \alpha \right) =n\left( -\frac {\Sigma x ^{\alpha }_iln x_{i}} {\sum x_{i}^{\alpha }}+\frac {1} {\alpha }+\frac {1} {n}\Sigma \delta_i\ln x_{i}\right)\tag{10}</script><p>求导可得</p>
<script type="math/tex; mode=display">
h'\left( \alpha \right) =n\left( -\frac {1} {\alpha^2}+\frac {\sum x_{i}^{\alpha }\left( ln x_{i}\right) ^{\alpha }} {\sum x_{i}^{\alpha }}-\frac {\left( \sum x_{i}^{\alpha }\ln x_{i}\right) ^{2}} {\left( \sum x_i^{\alpha }\right) ^{2}}\right)</script><p>因而，我们通过牛顿法迭代搜索非线性方程 $h(\alpha)=0$ 的解。</p>
<script type="math/tex; mode=display">
\alpha_{k+1}=\alpha_{k}-\frac{h\left(\alpha_{k}\right)}{h^{\prime}\left(\alpha_{k}\right)}\tag{11}</script><p>求解出 $\alpha$ 后，通过 （7）即可求解 $\beta$ 。</p>
<h3 id="Weibull-MLE-程序实现："><a href="#Weibull-MLE-程序实现：" class="headerlink" title="Weibull MLE 程序实现："></a>Weibull MLE 程序实现：</h3><p>推导过程写完了，怎么用程序实现呢？从多年来失败的研究经验Shecan总结了一个道理：不要重复造轮子。（其实学习的时候重复造下轮子也有好处。） Shecan 发现Python有一个比较有意思的Package。 叫做Weibull，基本可以满足你大部分的研究需求。具体怎么使用，请参考下面的参考文献。但是，有时候我们依旧需要对模型进行改进，比如说两参数的Weibull分布改成三参数的Weibull分布。为满足这种需求，Shecan找出了Weibull Package MLE部分的源程序，并改写成了面向过程的编程方式，具体如下：</p>
<p>你可以把下面的代码复制到 Jupyter Notebook：</p>
<p>注明：程序来自于Weibull Package: </p>
<p><a href="Weibull Package Doc">https://weibull.readthedocs.io/en/latest/examples.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<p>测试数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fail_times = [ <span class="number">9402.7</span>, <span class="number">6082.4</span>, <span class="number">13367.2</span>, <span class="number">10644.6</span>, <span class="number">8632.0</span>, <span class="number">3043.4</span>, <span class="number">1034.5</span>, <span class="number">2550.9</span>, <span class="number">2550.9</span>, <span class="number">3637.1</span>]</span><br><span class="line">suspended = [<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>,<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>]</span><br><span class="line">data = pd.DataFrame(&#123;<span class="string">'data'</span>: fail_times, <span class="string">'susp'</span>:suspended&#125;)</span><br></pre></td></tr></table></figure>
<p>MLE Calibration: 通过以上的推导过程可以很容易的读懂这段代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filter the failed samples and extract values</span></span><br><span class="line">df_failed = data[data.susp == <span class="literal">False</span>].copy() </span><br><span class="line">dtf_failed = df_failed[<span class="string">"data"</span>].values</span><br><span class="line">df_failed[<span class="string">"ln_x_div_r"</span>] = df_failed.apply(<span class="keyword">lambda</span> s: np.log(s[<span class="string">'data'</span>])/len(df_failed), axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># extract data of all the values</span></span><br><span class="line">dtf_all = data[<span class="string">'data'</span>].values</span><br><span class="line"><span class="comment"># use Newton-Rhapson method for estimating the shape parameter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># give initial value for the shape paramter:</span></span><br><span class="line">shape = (((<span class="number">6.0</span> / np.pi ** <span class="number">2</span>)</span><br><span class="line">            * (np.sum(np.log(dtf_all) ** <span class="number">2</span>)</span><br><span class="line">            - ((np.sum(np.log(dtf_all))) ** <span class="number">2</span>) / dtf_all.size))</span><br><span class="line">            / (dtf_all.size - <span class="number">1</span>)) ** <span class="number">-0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10 iterations of the newton-rhapson method</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    a = np.sum(np.log(dtf_failed) * <span class="number">1.0</span>) / dtf_failed.size</span><br><span class="line">    b = np.sum(dtf_all ** shape)</span><br><span class="line">    c = np.sum((dtf_all ** shape) * np.log(dtf_all))</span><br><span class="line">    h = np.sum((dtf_all ** shape) * (np.log(dtf_all)) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    shape = shape + (a + (<span class="number">1.0</span> / shape) - (c / b)) / ((<span class="number">1.0</span> / shape ** <span class="number">2</span>) + ((b * h) - c ** <span class="number">2</span>) / b ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">shape = max(shape, <span class="number">0.005</span>)</span><br><span class="line">scale = (np.sum((dtf_all ** shape) / len(df_failed))) ** (<span class="number">1</span> / shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the results</span></span><br><span class="line">print(shape,scale)</span><br></pre></td></tr></table></figure>
<p><strong>题外话：小时候老师教育我们如果要成为一个成功的人，头悬梁，锥刺骨，卧薪尝胆，这些典故都很励志。可是长大后发现了一个残酷的真相，成功人士万里挑一，而千千万万的普通人虽然没有那么成功，却也在以一己之力改变世界。比如说战疫前线的医生和护士们，比如说用自己的才能为这次疫情做贡献的各路神仙。经历了这些事，这些人，Shecan开始反思，与其教育自己的孩子成为一个成功的人，不如教育他们尽一己之力做一个对社会有贡献的人，或许这样的人生会更自信，更快乐，并获得更高的自我效能感。这也算是Shecan开始做笔记，并分享笔记的原因吧。</strong></p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
        <tag>Calibration</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab Plot with User Defined Color</title>
    <url>/2020/02/21/MATLAB%20Plot%20user%20defined%20color/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MATLAB-Plot-如何自定义颜色"><a href="#MATLAB-Plot-如何自定义颜色" class="headerlink" title="MATLAB Plot 如何自定义颜色"></a>MATLAB Plot 如何自定义颜色</h2><p>Tip: Matlab 作图时最好保存成fig格式，便于以后修改。</p>
<p>写论文是一个漫长的过程，成文后最重要的一个问题就是如何让自己的论文排版和插图更加的好看，让枯燥的论文有一点生动的色彩。这里记录我在写论文时的困惑和一些小小的技巧。</p>
<a id="more"></a>
<p>以下面这个图为例：<br><img src="https://img-blog.csdnimg.cn/20200113001358688.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoZWNhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><em>X = linspace(0,5,51);<br>Y1 = sin(X);<br>Y2 = cos(0.5</em>X);<br>Z = 2<em>Y1+0.3</em>Y2;<br>plot(X,Y1,’color’,[1,0,1],’Marker’,’<em>‘);hold on;<br>plot(X,Y2,’color’,[0.9,0.5,0.5],’LineWidth’,2);hold on;<br>plot(X,Z,’color’,[0.9,1,0.7],’Marker’,’diamond’,’MarkerEdgeColor’,’r’)<br>xlabel(‘x’,’FontSize’,15)<br>ylabel(‘y’,’FontSize’,15)<br>title(‘Customized the plot color in Matlab’,’Color’,[0.7,0,1])<br>方括号中间的三个数字表示的三原色的比例，配色标准可以参考：Matlab配色<br>Plot的基本命令： plot(x,y,’property name’,property value)<br>如果不记得property name怎么办？不用担心，Matlab会给你提示，总是可以找到自己想要的。<br>如何画出渐变图？<br>当然是写个for循环就可以了。</em><br><img src="https://img-blog.csdnimg.cn/20200113001422904.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoZWNhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><em>clear all<br>hold off<br>X = linspace(-pi/2,pi/2,10)<br>figure(‘Color’,[0.94,1,0.94])<br>for i = 1:20<br>        plot(X,(-1)^(i)</em>i<em>X,’color’,[1-i</em>0.05,0+i<em>0.03,1-i</em>0.01],’LineWidth’,0.5+0.05<em>i);<br>        hold on;<br>end<br>axis([-pi/2,pi/2,-35,35])</em></p>
]]></content>
      <categories>
        <category>Coding Tips</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB cell 与 matrix 之间的转换</title>
    <url>/2020/02/21/MATLAB%20cell%20%E4%B8%8E%20matrix%20%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了Shecan在研究中遇到的Cell与matrix相互转换的问题。cell2mat可以转换比较简单的cell类型，但是如果复杂一些，需要用cat和reshape，permute相结合。</p>
<a id="more"></a>
<p><strong>Example 1</strong></p>
<p>cell2mat 可以实现简单的cell到矩阵的拼接，如</p>
<script type="math/tex; mode=display">
\{[1],[2];[3],[4]\}</script><p>变成</p>
<script type="math/tex; mode=display">
\left[ \begin{matrix} 1 & 2 \\ 3 & 4 \end{matrix} \right]</script><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = cell(<span class="number">2</span>);</span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">1</span>&#125; = <span class="number">1</span>; </span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">2</span>&#125; = <span class="number">2</span>;</span><br><span class="line">A&#123;<span class="number">2</span>,<span class="number">1</span>&#125; = <span class="number">3</span>;</span><br><span class="line">A&#123;<span class="number">2</span>,<span class="number">2</span>&#125; = <span class="number">4</span>;</span><br><span class="line">B = cell2mat(A)</span><br></pre></td></tr></table></figure>
<p><strong>Example 2</strong></p>
<p>输入：</p>
<script type="math/tex; mode=display">
A = \left\{ \begin{matrix}\left[ \begin{matrix} 2 & 2 \\ 2 & 2 \end{matrix} \right],\left[ \begin{matrix} 1 & 1 \\ 1 & 1 \end{matrix} \right]\end{matrix}\right\}</script><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = cell(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">1</span>&#125; = [<span class="number">2</span>,<span class="number">2</span>;<span class="number">2</span>,<span class="number">2</span>];</span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">2</span>&#125; = [<span class="number">1</span>,<span class="number">1</span>;<span class="number">1</span>,<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>cat(1,mat) 表示按列拼接， cat(2,mat)表示按行拼接，cat(3,mat)表示按第三个维度拼接。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">B = <span class="built_in">cat</span>(<span class="number">3</span>,A&#123;:&#125;);</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
B(:,:,1) = \left[ \begin{matrix} 2 & 2 \\ 2 & 2 \end{matrix} \right]\\
B(:,:,2) = \left[ \begin{matrix} 1 & 1 \\ 1 & 1 \end{matrix} \right]</script><p><strong>Example 3</strong></p>
<p>输入：</p>
<script type="math/tex; mode=display">
\left\{ \begin{matrix} \left[ \begin{matrix} 2 \\ 1 \end{matrix} \right] &  \left[ \begin{matrix} 2 \\ 1 \end{matrix} \right]\\ \left[ \begin{matrix} 2 \\ 1 \end{matrix} \right] &  \left[ \begin{matrix} 2 \\ 1 \end{matrix} \right]\end{matrix}\right\}</script><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A = cell(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">1</span>&#125; = [<span class="number">2</span>;<span class="number">1</span>]; </span><br><span class="line">A&#123;<span class="number">1</span>,<span class="number">2</span>&#125; = [<span class="number">2</span>;<span class="number">1</span>];</span><br><span class="line">A&#123;<span class="number">2</span>,<span class="number">1</span>&#125; = [<span class="number">2</span>;<span class="number">1</span>];</span><br><span class="line">A&#123;<span class="number">2</span>,<span class="number">2</span>&#125; = [<span class="number">2</span>;<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; 2×2 cell 数组</span><br><span class="line">    &#123;2×1 double&#125;    &#123;2×1 double&#125;</span><br><span class="line">    &#123;2×1 double&#125;    &#123;2×1 double&#125;</span><br></pre></td></tr></table></figure>
<p>目标： 把 A 转换成以下的矩阵B</p>
<script type="math/tex; mode=display">
B(:,:,1) = \left[ \begin{matrix} 2 & 2 \\ 2 & 2 \end{matrix} \right]\\
B(:,:,2) = \left[ \begin{matrix} 1 & 1 \\ 1 & 1 \end{matrix} \right]</script><script type="math/tex; mode=display">
</script><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">B = <span class="built_in">cat</span>(<span class="number">2</span>,A&#123;:&#125;)</span><br></pre></td></tr></table></figure>
<p>% cat(1,mat) 表示按列拼接， cat(2,mat)表示按行拼接，cat(3,mat)表示按第三个维度拼接。</p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B &#x3D; 2×4</span><br><span class="line">     2     2     2     2</span><br><span class="line">     1     1     1     1</span><br></pre></td></tr></table></figure>
<p>以上的矩阵转置后reshape便可以的到需要的矩阵。reshape矩阵变换的优先方向是列-行-第三维度。</p>
<p>输入：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reshape</span>(B',[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans &#x3D; </span><br><span class="line">ans(:,:,1) &#x3D;</span><br><span class="line"></span><br><span class="line">     2     2</span><br><span class="line">     2     2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans(:,:,2) &#x3D;</span><br><span class="line"></span><br><span class="line">     1     1</span><br><span class="line">     1     1</span><br></pre></td></tr></table></figure>
<p>Alternatively, reshape based on columns. 如此，需要多费一番周折，最后需要一个高维矩阵转置。这样做的有点是当矩阵大于三维的时候比较容易理解和思考。</p>
<p>输入：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">B = <span class="built_in">cat</span>(<span class="number">1</span>,A&#123;:&#125;)</span><br></pre></td></tr></table></figure>
<p>输出：因为这里是按列拼接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B &#x3D; 8×1</span><br><span class="line">     2</span><br><span class="line">     1</span><br><span class="line">     2</span><br><span class="line">     1</span><br><span class="line">     2</span><br><span class="line">     1</span><br><span class="line">     2</span><br><span class="line">     1</span><br></pre></td></tr></table></figure>
<p>同样，reshape成三维矩阵。</p>
<p>输入：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">B=<span class="built_in">reshape</span>(B,[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>输出：得到这样的结果是因为reshape是先放到列，再放到行，最后放到第三维度。这个和MATLAB矩阵存储方式有关，列优先。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B &#x3D; </span><br><span class="line">B(:,:,1) &#x3D;</span><br><span class="line"></span><br><span class="line">     2     2</span><br><span class="line">     1     1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B(:,:,2) &#x3D;</span><br><span class="line"></span><br><span class="line">     2     2</span><br><span class="line">     1     1</span><br></pre></td></tr></table></figure>
<p>最后做一个一三维度的装置即可。</p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permute(B,[3,2,1])</span><br></pre></td></tr></table></figure>
<p>即可以得到所需要的矩阵。</p>
<p>结束语：寥寥记下几笔。说到cell，必须要在这里感谢一下昔日的老友，从他的程序里学来的，然后越用越顺手。</p>
]]></content>
      <categories>
        <category>Coding Tips</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab 高维矩阵与向量的点乘 （Permute）</title>
    <url>/2020/02/21/Matlab%20%E9%AB%98%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%90%91%E9%87%8F%E7%9A%84%E7%82%B9%E4%B9%98%20%EF%BC%88Permute%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Matlab-高维矩阵与向量的点乘-（Permute）"><a href="#Matlab-高维矩阵与向量的点乘-（Permute）" class="headerlink" title="Matlab 高维矩阵与向量的点乘 （Permute）"></a>Matlab 高维矩阵与向量的点乘 （Permute）</h1><p>今天遇到一个问题，如何用一个n维的向量点乘一个$m\times k\times n$ 的矩阵， 并避免用循环。Matlab矩阵实验室名不虚传，通过permute这个命令可以有效解决这个问题。因此记录下来，以备不时之需 （几年前遇到过同样的问题，但是没做笔记，所以这次一定要记下来）。</p>
<a id="more"></a>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">% 这里需要注意Matlab是按列存储的；</span></span><br><span class="line">test = <span class="built_in">repmat</span>(a,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>); <span class="comment">% 把向量a复制成一个3*3*3的矩阵；</span></span><br></pre></td></tr></table></figure>
<p> 查看test矩阵</p>
<script type="math/tex; mode=display">
test\left( :,: ,1\right) =\left[ \begin{matrix} 1& 2& 3\\ 1& 2& 3\\ 1& 2& 3\end{matrix} \right],test\left( :,: ,2\right) =\left[ \begin{matrix} 1& 2& 3\\ 1& 2& 3\\ 1& 2& 3\end{matrix} \right], test\left( :,: ,3\right) =\left[ \begin{matrix} 1& 2& 3\\ 1& 2& 3\\ 1& 2& 3\end{matrix} \right]</script><p>我想要的结果</p>
<script type="math/tex; mode=display">
testz\left( :,: ,1\right) =\left[ \begin{matrix} 1& 2& 3\\ 1& 2& 3\\ 1& 2& 3\end{matrix} \right],testz\left( :,: ,2\right) =\left[ \begin{matrix} 10& 20& 30\\ 10& 20& 30\\ 10& 20& 30\end{matrix} \right], testz\left( :,: ,3\right) =\left[ \begin{matrix} 100& 200& 300\\ 100& 200& 300\\ 100& 200& 300\end{matrix} \right]</script><p>实现的方法</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">z = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>]; <span class="comment">% 定义一个向量z</span></span><br><span class="line">test_z = <span class="built_in">permute</span>(z,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])； <span class="comment">%permute 用于求三维矩阵的转置</span></span><br></pre></td></tr></table></figure>
<p>对于二维矩阵的转置，我们通常用 ’ ；但是对于高维向量，需要使用permute, 上面的命令表示第二个维度的数据（列）放到第三个维度，所以我们猜测test_z会是一个 $1\times 1\times 3$的这么一个矩阵，查看test_z的结果</p>
<script type="math/tex; mode=display">
test_z\left( :,: ,1\right) = 1；test_z\left( :,: ,2\right) = 10； test_z\left( :,: ,3\right)=100；</script><p>如你所愿，最后我们有</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">testz = test_z.*test; <span class="comment">% 得到我想要的效果</span></span><br></pre></td></tr></table></figure>
<p>注意，如果是对行(第一维度)点乘，只需要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">z.* test</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
testz\left( :,: ,1\right) =\left[ \begin{matrix} 1& 2& 3\\ 10& 20& 30\\ 100& 200& 300\end{matrix} \right],testz\left( :,: ,2\right) =\left[ \begin{matrix} 1& 2& 3\\ 10& 20& 30\\ 100& 200& 300\end{matrix} \right], testz\left( :,: ,3\right) =\left[ \begin{matrix} 1& 2& 3\\ 10& 20& 30\\ 100& 200& 300\end{matrix} \right]</script><p>如果对列进行点乘，需要进行行列转置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">z&#39;.*test</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
testz\left( :,: ,1\right) =\left[ \begin{matrix} 1& 20& 300\\ 1& 20& 300\\ 1& 20& 300\end{matrix} \right],testz\left( :,: ,2\right) =\left[ \begin{matrix} 1& 20& 300\\ 1& 20& 300\\ 1& 20& 300\end{matrix} \right], testz\left( :,: ,3\right) =\left[ \begin{matrix} 1& 20& 300\\ 1& 20& 300\\ 1& 20& 300\end{matrix} \right]</script><p>虽然很简单，但是这么简单的问题我也是花了大概二十分钟去思考，再花二十分钟做笔记，希望以后可以帮助自己和有缘人。能遇到同样的变态问题，还看到我的博客，说明都是猿粪啊，既然这么有缘，你舍得不给我点赞吗？哈哈</p>
]]></content>
      <categories>
        <category>Coding Tips</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Shecan|Monte Carlo Simulation for CIR Process</title>
    <url>/2020/02/21/Monte%20Carlo%20Simulation%20for%20CIR%20Process/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Monte-Carlo-Simulation-for-CIR-Process"><a href="#Monte-Carlo-Simulation-for-CIR-Process" class="headerlink" title="Monte Carlo Simulation for CIR Process"></a>Monte Carlo Simulation for CIR Process</h1><p>(To be continued ……)</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Two models are commonly applied to describe the stochastic interest rate process (or the stochastic volatility process), including the OU process and the CIR process.</p>
<a id="more"></a>
<ul>
<li>The OU process:</li>
</ul>
<script type="math/tex; mode=display">
d r_{t}=\alpha\left(\mu-r_{t}\right) d t+\sigma d W_{t}\tag{1}</script><ul>
<li>The CIR process:</li>
</ul>
<script type="math/tex; mode=display">
d r_{t}=\alpha\left(\mu-r_{t}\right) d t+\sigma \sqrt{r_{t}} d W_{t}\tag{2}</script><p>where $\mu$ is the mean reversion level and $\alpha$ is the mean reversion speed.</p>
<p>Both of the models are mean-reverted, however, the OU process cannot ensure the nonnegativity of the interest rate. The OU process is driven by a normal distribution, but the underlying distribution of the CIR process is a non-central Chi-square distribution. </p>
<h2 id="Monte-Carlo-Simulation"><a href="#Monte-Carlo-Simulation" class="headerlink" title="Monte Carlo Simulation"></a>Monte Carlo Simulation</h2><p>Two methods are commonly applied to simulate the stochastic process, including the <strong>Euler–Maruyama Method</strong> and the <strong>Milstein Method</strong>. The differences between the two methods are the way of discretization and the order of convergence. The preliminary knowledge of the two discretization is the Ito Taylor expansion (For deriving details, please refer to the reference ‘Ito Taylor Expansion’). </p>
<script type="math/tex; mode=display">
X\left(t_{i+1}\right)=X\left(t_{i}\right)+a\left[X\left(t_{i}\right)\right] \Delta t+b\left[X\left(t_{i}\right)\right] \Delta W_{i}+\frac{1}{2} b\left[X\left(t_{i}\right)\right] b^{\prime}\left[X\left(t_{i}\right)\right]\left[\left(\Delta W_{i}\right)^{2}-\Delta t\right]+\mathcal{O}(\Delta t)</script><p>The Euler-Maruyama method is the first-order truncation of the Ito Taylor expansion and the Milstein Method is the second-order truncation of the Ito Taylor expansion. </p>
<p>Specifically, for the CIR process, we have $a[r] = \alpha(\mu - r)$, $b[r]=\sigma\sqrt{r}$, and $b’[r]=\frac{1}{2}\frac{\sigma}{\sqrt{r}}$.</p>
<ul>
<li>The Euler-Maruyama Method:</li>
</ul>
<script type="math/tex; mode=display">
r_{j}=r_{j-1}+\alpha\left(\mu - r_{j-1}\right) \Delta t+\sigma\sqrt{r_{j-1}}\Delta W_j, \quad j=1,2, \ldots, L</script><p>where $\Delta W_j = \sqrt{\Delta t}N(1,0)$.</p>
<ul>
<li>The Milstein Method:</li>
</ul>
<script type="math/tex; mode=display">
r_{j}=r_{j-1}+\alpha\left(\mu - r_{j-1}\right) \Delta t+\sigma\sqrt{r_{j-1}}\Delta W_j+\frac{\sigma^2}{2}[(\Delta W_j)^2-\Delta t], \quad j=1,2, \ldots, L</script><p>The weak and strong convergence rate of Euler-Maruyama are $\mathcal{}$$\mathcal{O}(\Delta t)$. The Milstein scheme has the same weak convergence but better strong convergence rate of $\mathcal{O}(\sqrt{\Delta t)}$. The detail definition of the weak and the strong convergence rate refer to <em>Higham (2001).</em></p>
<h2 id="Python-Code"><a href="#Python-Code" class="headerlink" title="Python Code"></a>Python Code</h2><p>For further extension, I wrote a class file first.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Wed Feb 26 22:42:55 2020</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Shecan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">please save the file as CIR.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CIR</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, alpha, mu, sigma, r0)</span>:</span></span><br><span class="line">         self.alpha = alpha <span class="comment"># mean-reverted speed</span></span><br><span class="line">         self.mu = mu <span class="comment"># mean-reverted level</span></span><br><span class="line">         self.sigma = sigma <span class="comment"># vol of interest rate</span></span><br><span class="line">         self.r0 = r0 <span class="comment"># initial interest rate</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Euler</span><span class="params">(self,t_init,t_end,dt)</span>:</span></span><br><span class="line">        np.random.seed(<span class="number">5</span>)</span><br><span class="line">        ts = np.arange(t_init, t_end, dt)</span><br><span class="line">        dW = np.random.normal(loc=<span class="number">0.0</span>, scale=np.sqrt(dt),size = ts.size)</span><br><span class="line">        r = []</span><br><span class="line">        r.append(self.r0)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, ts.size):</span><br><span class="line">            r.append(r[i<span class="number">-1</span>] + self.alpha*(self.mu-r[i<span class="number">-1</span>])*dt </span><br><span class="line">                     + self.sigma*np.sqrt(r[i<span class="number">-1</span>])*dW[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Milstein</span><span class="params">(self,t_init,t_end,dt)</span>:</span></span><br><span class="line">        np.random.seed(<span class="number">5</span>)</span><br><span class="line">        ts = np.arange(t_init, t_end, dt)</span><br><span class="line">        dW = np.random.normal(loc=<span class="number">0.0</span>, scale=np.sqrt(dt),size = ts.size)</span><br><span class="line">        r = []</span><br><span class="line">        r.append(self.r0)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, ts.size):</span><br><span class="line">            dw = dW[i<span class="number">-1</span>]</span><br><span class="line">            r.append(r[i<span class="number">-1</span>] + self.alpha*(self.mu-r[i<span class="number">-1</span>])*dt </span><br><span class="line">                     + self.sigma*np.sqrt(r[i<span class="number">-1</span>])*dw + </span><br><span class="line">                     (self.sigma**<span class="number">2</span>/<span class="number">2</span>)*(dw**<span class="number">2</span> - dt))</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>Then we can load the class file in Jupyter notebook, </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> CIR <span class="keyword">import</span> CIR <span class="comment"># from the module CIR load our class-file CIR</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># assume mean-reverted speed = 1, mean-reverted level = 0.05, vol of interest rate = 0.05, initial interest rate = 0.05, and pass to an object named C </span></span><br><span class="line">C = CIR(<span class="number">1</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0.05</span>)</span><br><span class="line"><span class="comment"># For Euler method</span></span><br><span class="line">r = C.Euler(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.001</span>) <span class="comment"># start time = 0, end time = 1, dt = 0.01</span></span><br><span class="line"><span class="comment"># For Milstern method</span></span><br><span class="line">r1 = C.Milstein(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.001</span>)</span><br><span class="line"><span class="comment"># Plot and compare</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">l1,=plt.plot(r)</span><br><span class="line">l2,=plt.plot(r1,<span class="string">'b*'</span>,markersize=<span class="number">4</span>)</span><br><span class="line">plt.ylabel(<span class="string">'interest rate r'</span>,fontsize = <span class="number">20</span>)</span><br><span class="line">plt.legend(handles=[l1, l2], labels=[<span class="string">'Euler'</span>, <span class="string">'Milstein'</span>], fontsize = <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>Visualizing the results:</p>
<p><img src="https://img-blog.csdnimg.cn/20200303225854819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70" alt="Monte Carlo Simulation"></p>
<h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p>CIR Modeling of Interest Rates</p>
<p><a href="http://lnu.diva-portal.org/smash/get/diva2:1270329/FULLTEXT01.pdf" target="_blank" rel="noopener">http://lnu.diva-portal.org/smash/get/diva2:1270329/FULLTEXT01.pdf</a></p>
<p>Enlightened reading material</p>
<p><em>Higham, D. J. (2001). An algorithmic introduction to numerical simulation of stochastic differential equations. SIAM review, 43(3), 525-546.</em></p>
<p>Ito-Taylor Expansion</p>
<p><a href="https://www.math.nyu.edu/~cai/Courses/Derivatives/compfin_lecture_5.pdf" target="_blank" rel="noopener">https://www.math.nyu.edu/~cai/Courses/Derivatives/compfin_lecture_5.pdf</a></p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>Shecan| VIX 指数构造详细证明过程</title>
    <url>/2020/02/21/VIX%20%E6%8C%87%E6%95%B0%E6%9E%84%E9%80%A0%E8%AF%A6%E7%BB%86%E8%AF%81%E6%98%8E%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="VIX-指数构造详细证明过程"><a href="#VIX-指数构造详细证明过程" class="headerlink" title="VIX 指数构造详细证明过程"></a>VIX 指数构造详细证明过程</h1><p>VIX—CBOE发行的波动率指数，又称为恐慌指数，VIX指数高的时候，说明投资者预期后市市场波动比较大，因而可以作为投资者情绪的一种预期，一般来说，如果市场是有效的话，VIX指数和标的（SPX100）之间具有杠杆效应，也就是说，标的资产的价格下降，VIX飙升。VIX指数最新的构造方法借鉴于【1】构造variance swap的方法，又称静态复制法，这篇文章的主旨是记录shecan读文章时的推导思路，所以不过多介绍背景了，直接切入正题。</p>
<a id="more"></a>
<p>VIX指数构造证明过程主要有以下的三个部分：</p>
<script type="math/tex; mode=display">
\sigma^{2} = \frac{2}{T}\int_{0}^{T}\frac{\text{dS}}{S} - \frac{2}{T}ln(\frac{S_{T}}{S_{0}}) \tag{1*}</script><script type="math/tex; mode=display">
E\left( \sigma^2 \right) = \frac{2}{T}\ln\left( \frac{F}{S^{*}} \right) - \frac{2}{T}\left\lbrack \frac{F}{S^{*}} - 1 \right\rbrack \\+ \frac{2}{T}\lbrack\int_{S_{*}}^{\infty}{C_T(K)dK +}\int_{0}^{S_{*}}{\frac{1}{K^{2}}P_T(K)\text{dK}}\tag{2*}</script><script type="math/tex; mode=display">
E(\sigma^{2}) = \frac{2}{T}\sum_{i = 1}^{n}{\frac{\mathrm{\Delta}K_{i}}{K_{i}}e^{\text{rT}}Q\left( K_{i} \right)} - \frac{1}{T}{\lbrack\frac{F}{K_{0}} - 1\rbrack}^{2}\tag{3*}</script><p><strong>（1*）根据股票过程和对数股票过程推导出波动率过程</strong>：</p>
<p>假设股票过程是一个几何布朗运动，则根据伊藤引理，可以推导出对数股票过程满足的随机过程，</p>
<script type="math/tex; mode=display">
\left\{ \begin{matrix}
\frac{\text{dS}}{S} = \mu dt + \sigma dz\ \ \ \ \ \ (1) \\
dlnS = \left( \mu - \frac{1}{2}\sigma^{2} \right)dt + \sigma dz\ (2) \\
\end{matrix} \right.\</script><p>（1）-（2）得</p>
<script type="math/tex; mode=display">
\frac{1}{2}\sigma^{2}T =\frac{\text{dS}}{S} - dlnS\tag{3}</script><p>对(3)两边求积分并化简即可得（1*）。</p>
<p><strong>（2*）根据（1*）构造静态复制表达式</strong>：</p>
<p>首先，对(1*)两边求期望得，</p>
<script type="math/tex; mode=display">
E\left( \sigma^{2} \right) = \frac{2}{T}\left(E\left( \int_{0}^{T}\frac{\text{dS}}{S} \right) - E(ln(\frac{S_{T}}{S_{0}}))\right)\tag{4}</script><p>在风险中性条件下，$E\left( \int_{0}^{T}\frac{\text{dS}}{S} \right) = ln(\frac{F}{S_0})$, 剩下求$E(ln(\frac{S_{T}}{S_{0}}))$:</p>
<p>其中其中$S_{*}$是静态复制时看涨期权和看跌期权的边界值，可以对$\ln\left( \frac{S_{T}}{S_{0}} \right)$做如下的分解</p>
<script type="math/tex; mode=display">
\ln\left( \frac{S_{T}}{S_{0}} \right) = \ln\left( \frac{S_{T}}{S_{*}} \right) + \ln\left( \frac{S_{*}}{S_{0}} \right)\tag{5}</script><p>最后需要证明的即是</p>
<script type="math/tex; mode=display">
\ln\left( \frac{S_{T}}{S_{*}} \right)= \frac{S_{T} - S_{*}}{S_{*}} - \int_{S_{*}}^{\infty}{\frac{1}{K^{2}}{(S_{T} - K)}^{+}dK -}\int_{0}^{S_{*}}{\frac{1}{K^{2}}\left( K - S_{T} \right)^{+}\text{dK}}\tag{6}</script><p>下面给出两个证明</p>
<p>证明1 证明等式是否恒等</p>
<script type="math/tex; mode=display">\int_{0}^{S_{*}}{\frac{1}{K^{2}}\left( K - S_{T} \right)^{+}\text{dK}} &=\int_{0}^{S_{T}}{\frac{1}{K^{2}}\left( K - S_{T} \right)^{+}\text{dK}}+\int_{S_{T}}^{S_{*}}{\frac{1}{K^{2}}\left( K - S_{T} \right)^{+}\text{dK}}\\&= \left\{ \begin{matrix}
0\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ S_{*} < K\  \\
\int_{S_{T}}^{S_{*}}{\frac{1}{K^{2}}\left( K - S_{T} \right)^{+}\text{dK}}\text{\ \ }S_{*} > K\  \\
\end{matrix} \right.\</script><p>同理，有下面的结论</p>
<script type="math/tex; mode=display">\int_{S_{*}}^{\infty}{\frac{1}{K^{2}}{(S_{T} - K)}^{+}dK =}\left\{ \begin{matrix}
\int_{S_{*}}^{S_{T}}{\frac{1}{K^{2}}{(S_{T} - K)}^{+}\text{dK}}\text{\ \ }S_{*} < K\  \\
0\text{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }S_{*} > K\  \\
\end{matrix} \right.\</script><p>假设</p>
<script type="math/tex; mode=display">\left\{ \begin{matrix}
P\left( K \right) = \left( K - S_{T} \right)^{+}\text{\ \ \ \ \ }\  \\
C\left( K \right) = {(S_{T} - K)}^{+}\text{\ \ \ \ \ }\  \\
\end{matrix} \right.\</script><p>则由平价公式$S_{T} = C_{T}\left( K \right) - P_{T}\left( K \right) + K$，则</p>
<script type="math/tex; mode=display">\ln\left( \frac{S_{T}}{S_{*}} \right) = \frac{S_{T} - S_{*}}{S_{*}} - \int_{S_{*}}^{\infty}{\frac{1}{K^{2}}{(S_{T} - K)}^{+}dK -}\int_{0}^{S_{*}}{\frac{1}{K^{2}}\left( K - S_{T} \right)^{+}\text{dK}}</script><p>=$\frac{S_{T} - S_{<em>}}{S_{</em>}} - \int_{S_{<em>}}^{S_{T}}{\frac{1}{K^{2}}{(S_{T} - K)}^{+}dK -}\int_{S_{T}}^{S_{</em>}}{\frac{1}{K^{2}}\left( K - S_{T} \right)^{+}\text{dK}}$</p>
<p>=$\frac{S_{T} - S_{<em>}}{S_{</em>}} - \int_{S_{T}}^{S_{*}}{\frac{1}{K^{2}}{\lbrack\left( K - S_{T} \right)}^{+} - \left( S_{T} - K \right)^{+}\rbrack dK}$</p>
<p>=$\frac{S_{T} - S_{<em>}}{S_{</em>}} - \int_{S_{T}}^{S_{*}}{\frac{1}{K^{2}}{\lbrack S_T-K\rbrack dK}}$</p>
<p>=$\frac{S_{T} - S_{<em>}}{S_{</em>}} - \ln\left( \frac{S_{T}}{S_{<em>}} \right) - \frac{S_{T}}{S_{</em>}} + 1$</p>
<p>=$\ln\left( \frac{S_{*}}{S_{T}} \right)$</p>
<p>证明2 更加一般的形式</p>
<p>这个形式来源于文档【2】，当时看的时候真的觉得特别牛逼，之后很多扩展都是基于这个形式扩展的，包括skew指数的构造，但是看了作者的证明（当然作者也是特别牛逼，心生敬畏，carr and madan, 上一次看见这个名字还是在学习快速傅里叶变换应用于期权定价），云里雾里，于是按着自己的理解重新写了一遍他们的证明过程，但是数学基础还是比较欠缺，希望有缘看到我这篇笔记的大牛们来帮我订正一下~</p>
<p>Carr和Madan认为任何连续的payoff都可以写成如下的形式，当然个人认为这个payoff还必须是光滑的，至少要保证二阶可导，这个表达式牛逼之处就在于，后面静态复制的部分包含了所有泰勒的高阶项~</p>
<script type="math/tex; mode=display">
f\left( S_{T} \right) = f\left( S_* \right) + f^{'}\left( S_* \right)\left( S_{T} - S_* \right) + \int_{a}^{\infty}{f^{''}\left( K \right)\left( S_{T} - K \right)^{+}dK +}\int_{0}^{a}{f''(K)\left( K - S_{T} \right)^{+}\text{dK}}\tag{NB}</script><p>现在我们来看看（NB）表达式的证明过程</p>
<script type="math/tex; mode=display">f\left( F \right) = \int_{0}^{\infty}{f\left( K \right)\delta\left( F - K \right)\text{dK}}</script><p>=$\int_{0}^{\overline{K}}{f\left( K \right)\delta\left( F - K \right)\text{dK}} + \int_{\overline{k}}^{\infty}{f\left( K \right)\delta\left( F - K \right)\text{dK}}$</p>
<p>=$\int_{0}^{\overline{k}}{f\left( K \right)\text{dI}\left( F &lt; K \right)} + \int_{\overline{k}}^{\infty}{f\left( K \right)\text{dI}\left( F \geq K \right)}$</p>
<p>=$\text{\ f}\left( K \right)I\left( F &lt; K \right)|_{0}^{\overline{k}} - \int_{0}^{\overline{k}}{f’{\left( K \right)}I\left( F &lt; K \right)\text{dK}} - f\left( K \right)I\left( F \geq K \right)|_{\overline{k}}^{\infty} + \int_{\overline{k}}^{\infty}{f’\left( K \right)\delta\left( F \geq K \right)\text{dK}}$</p>
<p>=$\text{\ f}\left( \overline{k} \right) - \int_{0}^{\overline{k}}{f^{‘}(K)d\left( K - F \right)^{+}} - \int_{\overline{k}}^{\infty}{f’\left( K \right)d\left( F - K \right)^{+}}$</p>
<p>=$\text{\ f}\left( \overline{k} \right) - f^{‘}\left( K \right)\left( K - F \right)^{+}|_{0}^{\overline{k}} + \int_{0}^{\overline{k}}{f’’\left( k \right)\left( K - F \right)^{+}\text{dK}} - f’{\left( K \right)\left( F - K \right)^{+}|_{\overline{k}}^{\infty}} + \int_{\overline{k}}^{\infty}{f’’\left( K \right)\left( F - K \right)^{+}\text{dK}}$</p>
<p>=$\text{\ f}\left( \overline{k} \right) + f^{‘}\left( k \right)\left\lbrack \left( F - \overline{k} \right)^{+} - \left( \overline{k} - F \right)^{+} \right\rbrack + \int_{0}^{\overline{k}}{f’’\left( K \right)\left( K - F \right)^{+}}dK + \int_{\overline{k}}^{\infty}{f’’\left( K \right)\left( F - K \right)^{+}\text{dK}}$</p>
<p>令$f\left( S_{T} \right)=\ln\left( \frac{S_{<em>}}{S_{T}} \right) - \frac{S_{T}}{S_{</em>}} + 1$,</p>
<p>代入(NB)有:</p>
<script type="math/tex; mode=display">
\ln\left( \frac{S_{T}}{S_{*}} \right) - \frac{S_{T}}{S_{*}} + 1=- \int_{S_{*}}^{\infty}{\frac{1}{K^{2}}{(S_{T} - K)}^{+}dK -}\int_{0}^{S_{*}}{\frac{1}{K^{2}}\left( K - S_{T} \right)^{+}\text{dK}}</script><p>综合（4）（5）（6）（7）可得</p>
<script type="math/tex; mode=display">
E\left( \sigma^{2} \right) = \frac{2}{T}\left(E\left( \int_{0}^{T}\frac{\text{dS}}{S} \right) - E(ln(\frac{S_{T}}{S_{0}}))\right)=\\\frac{2}{T}(ln(\frac{F}{S_*})-\frac{F - S_{*}}{S_{*}} + \int_{S_{*}}^{\infty}{\frac{1}{K^{2}}{C_T(K)dK +}\int_{0}^{S_{*}}{\frac{1}{K^{2}}P_T(K)\text{dK}})}</script><p>(3<em>) 即是对（2\</em>）的离散过程，比较简单了，哪天心情好再更新！</p>
<p>【1】Demeterfi, K. ,  Derman, E. ,  Kamal, M. , &amp;  Zou, J. . (1999). More than you ever wanted to know about volatility swaps. <em>Quantitative Strategies Research Notes Goldman Sachs</em>.</p>
<p>【2】P Carr, &amp; M Stanley. (1997). Towards a theory of volatility trading.</p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Cheatsheet</title>
    <url>/2020/02/21/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="hexo-debug"><a href="#hexo-debug" class="headerlink" title="hexo debug"></a>hexo debug</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo debug</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding Tips</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Shecan|一般随机抽样</title>
    <url>/2020/02/21/%E4%B8%80%E8%88%AC%E6%8A%BD%E6%A0%B7%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一般随机抽样"><a href="#一般随机抽样" class="headerlink" title="一般随机抽样"></a>一般随机抽样</h1><p>我们知道蒙特卡洛模拟在金融领域有着广泛的应用，比如说模拟股票的路径，通常来讲我们会假设股票价格服从以下的随机过程：</p>
<script type="math/tex; mode=display">
dS_t=rS_tdt+\sigma S_t dW_t\tag{1}</script><p>如果我们把以上的随机过程离散化，就有如下的表达式</p>
<script type="math/tex; mode=display">
S_{t+1}=S_{t}+rS_t\Delta t+\sigma S_t\Delta W_t\tag{2}</script><p>而$W_t$是一个布朗运动，因而$\Delta W_t$可以表示成$\Delta W_t=\sqrt{\Delta t}*\mathcal{N}(0,1)$。蒙特卡洛模拟即是产生服从正态分布的随机数，从而可以模拟出服从(1)的资产过程，详见<a href="http://shecan66.com/2020/02/21/CIR%E8%BF%87%E7%A8%8B%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%A8%A1%E6%8B%9F/" target="_blank" rel="noopener">CIR过程蒙特卡洛模拟</a>。</p>
<p>MATLAB中我们知道可以通过randn这个命令来产生服从正太分布的随机数，对于其它的分布形式，比如说Possion分布，Weibull分布，Binomial分布等等，我们也可以有现成的命令来产生相应的随机数。但是，如果我们要产生一些不常见分布的随机数，或者说如果大家好奇这些命令背后的过程，就需要说说随机数抽取的原理，我们这里所说的随机抽样即是已知分布形式时，如何产生相应的随机数。</p>
<a id="more"></a>
<p>通过分布抽取随机数通常有以下的方法：<br><img src="https://img-blog.csdnimg.cn/20201006142813103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="逆变换法"><a href="#逆变换法" class="headerlink" title="逆变换法"></a>逆变换法</h2><p>逆变换法的原理在于如果我们能够求出已知分布$Y=F(X)$的逆函数的解析形式，即$X=F^{-1}(Y)$, 我们即可以通过这个解析表达式来产生满足既定分布的随机数，这里需要注意的是，$Y$通常在0，1之间取值，所以我们假定它是一个0到1的均匀分布$U(0,1)$, 下面的几个例子可以帮助大家理解逆变换法的原理。</p>
<ol>
<li><p>均匀分布（Uniform Distribution）<br>pdf: $f(x)=\left\{\begin{array}{cc}<br>\frac{1}{b-a} &amp; a \leq x \leq b \\<br>0 &amp; \text { 其它 }<br>\end{array}\right.$<br>cdf: $F(x)=\frac{x-a}{b-a}, a \leq x \leq b$<br>Inverse Random: $x=(b-a) y+a$</p>
<p>Matlab 代码</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">u1=<span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">2000</span>);</span><br><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=<span class="number">5</span>;</span><br><span class="line">x1(<span class="number">1</span>:<span class="number">2000</span>)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">2000</span></span><br><span class="line">    x1(<span class="built_in">i</span>)=a+(b-a)*u1(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">hist(x1,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">100</span>);</span><br><span class="line">y=<span class="built_in">ones</span>(<span class="built_in">length</span>(t),<span class="number">1</span>).*<span class="number">1</span>/(b-a);</span><br><span class="line">scale=<span class="number">2000</span>*<span class="number">4</span>/<span class="number">10</span>;</span><br><span class="line"><span class="built_in">plot</span>(t,scale*y,<span class="string">'r'</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201006142920937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_10,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><p>指数分布指数分布（exponential distribution）<br>pdf: $f(x)=\left\{\begin{array}{cc}<br>\lambda e^{-i x} &amp; x&gt;0 \\<br>0 &amp; \text { 其它 }<br>\end{array}\right.$<br>cdf: $F\left(x\right)=1-e^{-\lambda x}, x&gt;0$<br>Inverse Random: $x=-\frac{1}{\lambda }\ln \left(1-y\right)$</p>
<p>Matlab 代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">u2=<span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">2000</span>);</span><br><span class="line">v=<span class="number">2</span>;</span><br><span class="line">X2(<span class="number">1</span>:<span class="number">2000</span>)=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">2000</span></span><br><span class="line">  X2(<span class="built_in">i</span>)=-<span class="built_in">log</span>(u2(<span class="built_in">i</span>))/v;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">hist(X2,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">t=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">5</span>,<span class="number">100</span>);</span><br><span class="line">y=<span class="built_in">exp</span>(-v*t).*v;</span><br><span class="line">scale=<span class="number">2000</span>*<span class="number">5</span>/<span class="number">10</span>;</span><br><span class="line"><span class="built_in">plot</span>(t,scale*y,<span class="string">'r'</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">cdfplot(X2)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020100614303350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<h2 id="函数变换法"><a href="#函数变换法" class="headerlink" title="函数变换法"></a>函数变换法</h2><p>有些分布的逆函数比较难求，比如说正态分布，这个时候我们可以通过变量替换的方法来得到解析表达式。</p>
<p>通过Box-Muller变换（直角坐标和极坐标的转换），我们可以有如下的表达式：</p>
<script type="math/tex; mode=display">
\begin{array}{c}
x_{1}=\left(-2 \ln r_{1}\right)^{1 / 2} \cos \left(2 \pi r_{2}\right) \\
x_{2}=\left(-2 \ln r_{1}\right)^{1 / 2} \sin \left(2 \pi r_{2}\right) \\
r_{1}, r_{2} \sim U(0,1)
\end{array}</script><p>详细推导过程见<a href="https://blog.csdn.net/weixin_41793877/article/details/84700875" target="_blank" rel="noopener">Box-Muller</a>。</p>
<p>Matlab 代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mm=<span class="number">10000</span>;</span><br><span class="line">R1=unifrnd(<span class="number">0</span>,<span class="number">1</span>,mm,<span class="number">1</span>);</span><br><span class="line">R2=unifrnd(<span class="number">0</span>,<span class="number">1</span>,mm,<span class="number">1</span>);</span><br><span class="line">X = <span class="built_in">sqrt</span>(<span class="number">-2</span>*<span class="built_in">log</span>(R1)).*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>.*R2);</span><br><span class="line"><span class="comment">% 可视化</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),cdfplot(X)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),histfit(X)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201006143158672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>可以通过k-s检验和qqplot的方法来检验它的正态性：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">h=kstest(X, [X normcdf(X, <span class="number">0</span>,<span class="number">1</span>)])<span class="comment">%h=0,  kstest fails to reject the null hypothesis at the default 5% significance level, suggesting it is normal distribution.</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">qqplot(X)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201006143228675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_10,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>comments: The plot produces an approximately straight line, suggesting that X follow a normal distribution.</p>
<h2 id="拒绝-接受法"><a href="#拒绝-接受法" class="headerlink" title="拒绝-接受法"></a>拒绝-接受法</h2><p>对于有些分布，我们无法求解出逆函数的解析表达式，拒绝-接受法给我们提供了一般抽样的另一种思路。</p>
<p><img src="https://img-blog.csdnimg.cn/20201006172346123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>直观解释就是我们假设另外一个已知的简单分布$g(x)$, 使得$Mg(x)$可以完全覆盖所需的分布$f(x)$。选取满足分布$g(x)$中的点，如果点落到$f(x)$中就接受它，否则就拒绝它。当然，这种解释是不严谨的，更加严谨的数学解释可以通过证明以下的概率公式来理解：</p>
<script type="math/tex; mode=display">
P(X<x)=P(y<x|u\leq \frac{f(y)}{cg(y)})</script><p>即右边的这个条件分布等同于我们所需的分布，因而我们可以用这个关系来进行随机抽样。详细的推导可以参见《随机模拟方法与应用》第五章，依然以正态分布为例：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N = <span class="number">100000</span>;</span><br><span class="line">M = <span class="number">1</span>/(<span class="built_in">sqrt</span>(<span class="number">2</span>*<span class="built_in">pi</span>));</span><br><span class="line">Y = unifrnd(<span class="number">-4</span>,<span class="number">4</span>,<span class="number">1</span>,N);</span><br><span class="line">U = unifrnd(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">gy = <span class="number">1</span>;</span><br><span class="line">fy = (<span class="number">1</span>/(<span class="built_in">sqrt</span>(<span class="number">2</span>*<span class="built_in">pi</span>)))*<span class="built_in">exp</span>(-Y.^<span class="number">2.</span>/<span class="number">2</span>);</span><br><span class="line">X = Y(U&lt;fy./gy/M);</span><br><span class="line">count = <span class="built_in">length</span>(X);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),histfit(X)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),cdfplot(X)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201006143856180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>同理，我们也可以用kstest和qqplot更为严谨地去检查它的正态性。</p>
<h2 id="多维随机抽样"><a href="#多维随机抽样" class="headerlink" title="多维随机抽样"></a>多维随机抽样</h2><h5 id="各个维度随机变量相互独立"><a href="#各个维度随机变量相互独立" class="headerlink" title="各个维度随机变量相互独立"></a>各个维度随机变量相互独立</h5><h5 id="各个维度随机变量不独立（Cholesky-Decomposition正交分解）"><a href="#各个维度随机变量不独立（Cholesky-Decomposition正交分解）" class="headerlink" title="各个维度随机变量不独立（Cholesky Decomposition正交分解）"></a>各个维度随机变量不独立（Cholesky Decomposition正交分解）</h5><p>如果我们要抽样出一个高维的随机分布，通常说我们要对其每个维度进行随机抽样，如果每个维度的变量之间是相互独立的，那么非常容易，我们只要对每个维度进行抽样，然后扩展到多维即可，依然以正态分布为例：</p>
<p>Matlab代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N=<span class="number">1000</span>;</span><br><span class="line">X=<span class="built_in">randn</span>(N,<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),<span class="built_in">plot</span>(X(:,<span class="number">1</span>),X(:,<span class="number">2</span>),<span class="string">'k.'</span>)</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),hist3(X,[<span class="number">10</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<p>可以画出二维独立正态分布的直方图和散点图：</p>
<p><img src="https://img-blog.csdnimg.cn/20201006143933305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>如果各个维度之间的分布不独立，具有一定的相关性，那我们又该如何抽样出具有相关性的高维随机变量呢，这个时候大家需要知道一个概念叫做Cholesky正交分解。</p>
<h3 id="Cholesky-Decomposition正交分解"><a href="#Cholesky-Decomposition正交分解" class="headerlink" title="Cholesky Decomposition正交分解"></a>Cholesky Decomposition正交分解</h3><p>目标：构造一个新的向量$Y=L^{-1} X$，使得</p>
<script type="math/tex; mode=display">
\textrm{cov}\left(Y,Y^T \right)=L^{-1} E\left(XX^T \right){\left(L^{-1} \right)}^T =L^{-1} \Sigma {\left(L^{-1} \right)}^T =\Sigma \Sigma^{-1} =I</script><p>其中$\Sigma$是协方差矩阵，I 是单位矩阵，L是一个下三角矩阵并满足$LL^T =\Sigma$。</p>
<p>反之，我们就可以通过独立向量$Y$， 反推出具有相关关系的$X$。</p>
<p>例如，生成一个三维的多元正态分布$X=\left(X_1 ,X_2 ,X_3 \right)$，其中，$X_1 \sim N\left(2,3\right)$,$X_2 \sim N\left(-1,2\right)$,$X_3 \sim N\left(0,1\right)$并满足如下的协方差矩阵</p>
<script type="math/tex; mode=display">
\Sigma =\left\lbrack \begin{array}{ccc}
1 & 0\ldotp 3 & 0\ldotp 4\\
0\ldotp 3 & 1 & 0\ldotp 2\\
0\ldotp 4 & 0\ldotp 2 & 1
\end{array}\right\rbrack</script><p>Matlab代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">N = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">% 生成独立的随机变量</span></span><br><span class="line">Y = [normrnd(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,N);normrnd(<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,N);normrnd(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,N)];</span><br><span class="line">rho = [<span class="number">1</span>,<span class="number">0.3</span>,<span class="number">0.4</span>;<span class="number">0.3</span>,<span class="number">1</span>,<span class="number">0.2</span>;<span class="number">0.4</span>,<span class="number">0.2</span>,<span class="number">1</span>];</span><br><span class="line">L = chol(rho,<span class="string">'lower'</span>);</span><br><span class="line"><span class="comment">% 构造一个协方差矩阵为Σ的随机变量</span></span><br><span class="line">X = L*Y;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">scatter</span>(X(<span class="number">1</span>,:),X(<span class="number">2</span>,:),<span class="string">'marker'</span>,<span class="string">'.'</span>,<span class="string">'sizedata'</span>,<span class="number">1</span>)</span><br><span class="line">xlabel(<span class="string">'X轴'</span>);ylabel(<span class="string">'Y轴'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">scatter</span>(X(<span class="number">2</span>,:),X(<span class="number">3</span>,:),<span class="string">'marker'</span>,<span class="string">'.'</span>,<span class="string">'sizedata'</span>,<span class="number">1</span>)</span><br><span class="line">xlabel(<span class="string">'X轴'</span>);ylabel(<span class="string">'Z轴'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">scatter</span>(X(<span class="number">3</span>,:),X(<span class="number">1</span>,:),<span class="string">'marker'</span>,<span class="string">'.'</span>,<span class="string">'sizedata'</span>,<span class="number">1</span>)</span><br><span class="line">xlabel(<span class="string">'Z轴'</span>);ylabel(<span class="string">'X轴'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">scatter3</span>(X(<span class="number">1</span>,:),X(<span class="number">2</span>,:),X(<span class="number">3</span>,:),<span class="string">'marker'</span>,<span class="string">'.'</span>,<span class="string">'sizedata'</span>,<span class="number">1</span>)</span><br><span class="line">xlabel(<span class="string">'X轴'</span>);ylabel(<span class="string">'Y轴'</span>);zlabel(<span class="string">'Z轴'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201006143958985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>肖柳青, 周石鹏. 随机模拟方法与应用[M]. 北京大学出版社, 2014.</p>
<p>Huynh. Stochastic Simulation and Applications in Finance with Matla[M]// Stochastic simulation and applications in finance with MATLAB programs</p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Simulation</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Shecan|单变量随机扩散过程的参数估计——Hermite近似笔记似然函数</title>
    <url>/2020/02/21/%E5%8D%95%E5%8F%98%E9%87%8F%E9%9A%8F%E6%9C%BA%E6%89%A9%E6%95%A3%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1%E2%80%94%E2%80%94Hermite%E5%BA%8F%E5%88%97%E8%BF%91%E4%BC%BC%E4%BC%B0%E8%AE%A1%E8%BD%AC%E7%A7%BB%E5%AF%86%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单变量随机扩散过程的参数估计——Hermite序列近似估计转移密度</p>
<p>这篇博文基于作者个人最近阅读Yacine（2002）年的一篇很经典的论文的理解。这篇文章比较牛逼之处在于可以通过Hermite序列近似估计出转移概率密度（regardless the underlying distribution），从而得到一个外生得似然函数。并且可以扩展到多维的随机过程。</p>
<p>(未完待续 ……)<br><a id="more"></a><br>虽然Yacine公开了程序，但是作者最近求知欲爆棚（比较无聊），所以记下自己的理解和自己猜测的一些推导细节。当然，刚开始学习，理解还浮于表面，如果有不到位的地方，希望路过的大牛能够指出。</p>
<p>对于一个一般的扩散过程：</p>
<script type="math/tex; mode=display">
d \boldsymbol{X}_{t}=\mu\left(\boldsymbol{X}_{t} ; \boldsymbol{\theta}\right) d t+\sigma\left(\boldsymbol{X}_{t} ; \boldsymbol{\theta}\right) d \boldsymbol{W}_{t}\tag{1}</script><p>比如说CIR过程：</p>
<script type="math/tex; mode=display">
d x_{t}=\alpha\left(\mu-x_{t}\right) d t+\sigma \sqrt{x_{t}} d W_{t}\tag{1*}</script><p>从作者的上一篇博文可知，CIR过程服从非中心卡方分布，转移概率计算相当复杂。但是通过一系列的变换，Yacine让以上的过程更加近似于正态分布，从而可以用Hermite序列来近似估计正态分布函数。这个变换就是一个从X到Z的过程。得到Z过程的近似转移概率后，我们可以倒推到X过程，从而推出外生的似然函数，最终目标如下：</p>
<script type="math/tex; mode=display">
\ell_{n}(\theta) \equiv \sum_{i=1}^{n} \ln \left\{p_{X}\left(\Delta, X_{i \Delta} | X_{(i-1) \Delta} ; \theta\right)\right\}\tag{**}</script><p>通过似然函数的最优化，即可以对未知参数进行估计。具体的变化过程如下：</p>
<p>第一步， 标准化，去除方差的影响。 $(X\rightarrow Y)$</p>
<script type="math/tex; mode=display">
Y \equiv \gamma(X ; \theta)=\int^{x} d u / \sigma(u ; \theta)\tag{2}</script><p>带入Ito公式</p>
<script type="math/tex; mode=display">
\begin{aligned}
&d Y_{s}=\mu_{Y}\left(Y_{t} ; \theta\right) d t+d W_{t}, \quad \text { where }\\
&\mu_{Y}(y ; \theta)=\frac{\mu\left(\gamma^{-1}(y ; \theta) ; \theta\right)}{\sigma\left(\gamma^{-1}(y ; \theta) ; \theta\right)}-\frac{1}{2} \frac{\partial \sigma}{\partial x}\left(\gamma^{-1}(y ; \theta) ; \theta\right)
\end{aligned}</script><p>第二步， 中心化，去除尖峰影响。$(Y\rightarrow Z)$</p>
<script type="math/tex; mode=display">
Z \equiv \Delta^{-1 / 2}\left(Y-y_{0}\right)\tag{3}</script><p>第三步，利用Hermite序列近似逼近Z的转移概率密度：</p>
<script type="math/tex; mode=display">
p_{Z}^{(J)}\left(\Delta, z | y_{0} ; \theta\right) \equiv \phi(z) \sum_{j=0}^{J} \eta_{Z}^{(j)}\left(\Delta, y_{0} ; \theta\right) H_{j}(z)\tag{4}</script><p>其中$\phi(z) \equiv e^{-z^{2} / 2} / \sqrt{2 \pi}$, 是标准的正态分布密度函数。而</p>
<script type="math/tex; mode=display">
H_{j}(z) \equiv e^{z^{2} / 2} \frac{d^{j}}{d z^{j}}\left[e^{-z^{2} / 2}\right], \quad j \geq 0\tag{5}</script><p>是标准的Hermite序列。系数项可以如下的积分过程得到</p>
<script type="math/tex; mode=display">
\eta_{Z}^{(j)}\left(\Delta, y_{0} ; \theta\right) \equiv(1 / j !) \int_{-\infty}^{+\infty} H_{j}(z) p_{Z}\left(\Delta, z | y_{0} ; \theta\right) d z\tag{6}</script><p>这里我想可以近似于傅里叶逼近来理解，毕竟Hermite序列也是正交序列。所以证明方法应该和傅里叶序列函数逼近差不多，因而我目前还不是特别好奇。</p>
<p>第四步，已知Z的状态转移密度，求Y的状态转移密度：$(Z\rightarrow Y)$</p>
<p>根据（3）和（4）：</p>
<script type="math/tex; mode=display">
p_{Y}^{(J)}\left(\Delta, y | y_{0} ; \theta\right) \equiv \Delta^{-1 / 2} p_{Z}^{(J)}\left(\Delta, \Delta^{-1 / 2}\left(y-y_{0}\right) | y_{0} ; \theta\right)\tag{7}</script><p>第五步，已知Y的转移密度，得到X的转移密度：$(Z\rightarrow Y)$</p>
<script type="math/tex; mode=display">
p_{X}^{(J)}\left(\Delta, x | x_{0} ; \theta\right) \equiv \sigma(x ; \theta)^{-1} p_{Y}^{(J)}\left(\Delta, \gamma(x, \theta) | \gamma\left(x_{0} ; \theta\right) ; \theta\right)\tag{8}</script><p>第六步，最大化似然函数（**）。</p>
<p>以上即为Yacine似然估计的整个流程，而这里最重要也最复杂的就是第三步，如何通过序列逼近$p_{Z}^{(J)}\left(\Delta, z | y_{0} ; \theta\right)$</p>
<p>通过较为简单的变量替换，我们有如下的结果</p>
<script type="math/tex; mode=display">
\begin{aligned}
\eta_{Z}^{(j)}\left(\Delta, y_{0} ; \theta\right) &=(1 / j !) \int_{-\infty}^{+\infty} H_{j}(z) p_{Z}\left(\Delta, z | y_{0} ; \theta\right) d z \\
&=(1 / j !) \int_{-\infty}^{+\infty} H_{j}(z) \Delta^{1 / 2} p_{Y}\left(\Delta, \Delta^{1 / 2} z+y_{0} | y_{0} ; \theta\right) d z \\
&=(1 / j !) \int_{-\infty}^{+\infty} H_{j}\left(\Delta^{-1 / 2}\left(y-y_{0}\right)\right) p_{Y}\left(\Delta, y | y_{0} ; \theta\right) d y \\
&=(1 / j !) E\left[H_{j}\left(\Delta^{-1 / 2}\left(Y_{t+\Delta}-y_{0}\right)\right) | Y_{t}=y_{0} ; \theta\right]
\end{aligned}</script><p>这里，第二行的推导参照（7），可以反解出：</p>
<script type="math/tex; mode=display">
p_{Z}\left(\Delta, z | y_{0} ; \theta\right)=\Delta^{1 / 2} p_{Y}\left(\Delta, \Delta^{1 / 2} z+y_{0} | y_{0} ; \theta\right)\tag{9}</script><p>第三行带入（3）即可。最后一行是期望的定义。然后最后一行的期望项用Tarlor公式展开:</p>
<script type="math/tex; mode=display">
E\left[f\left(Y_{t+\Delta}, y_{0}\right) | Y_{t}=y_{0}\right]= \sum_{k=0}^{K} A^{k}(\theta) \cdot f\left(y_{0}, y_{0}\right) \frac{\Delta^{k}}{k !} \\
+E\left[A^{K+1}(\theta) \cdot f\left(Y_{t+\delta}, y_{0}\right) | Y_{t}=y_{0}\right] \frac{\Delta^{K+1}}{(K+1) !}\tag{10}</script><p>这里 $f\left(y, y_{0}\right)=H_{j}\left(\Delta^{-1 / 2}\left(Y_{t+\Delta}-y_{0}\right)\right)$. 通过定义 （5），我们展开前七项的Hermite序列</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$H_0(z)$</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$H_1(z)$</td>
<td style="text-align:center">-x</td>
</tr>
<tr>
<td style="text-align:center">$H_2(z)$</td>
<td style="text-align:center">$x^2-1$</td>
</tr>
<tr>
<td style="text-align:center">$H_3(z)$</td>
<td style="text-align:center">$-x^3+3x$</td>
</tr>
<tr>
<td style="text-align:center">$H_4(z)$</td>
<td style="text-align:center">$x^4-6x^2+3$</td>
</tr>
<tr>
<td style="text-align:center">$H_5(z)$</td>
<td style="text-align:center">$-x^5+10x^3-15x$</td>
</tr>
<tr>
<td style="text-align:center">$H_6(z)$</td>
<td style="text-align:center">$x^6-15x^4+45x^2-15$</td>
</tr>
</tbody>
</table>
</div>
<p>而算子$A = \mu_y\frac{\partial}{\partial y} +\frac{1}{2}\frac{\partial^2}{\partial y^2}$。这里$\eta_{Z}^{(k,j)}\left(\Delta, y_{0} ; \theta\right)$有两个上标， k表示泰勒展开的阶数，j代表Hermite序列的阶数。Yacine在文章中给出了前七项的表达式，如图</p>
<p><img src="C:\Users\Hubu\Desktop\草稿\hermite.png" alt=""></p>
<p>还有第一项$\eta^{(0,3)}_Z=1$;</p>
<script type="math/tex; mode=display">
\eta_{Z}^{(1,3)}=-\mu_{Y} \Delta^{1 / 2}-\left(2 \mu_{Y} \mu_{Y}^{[1]}+\mu_{Y}^{[2]}\right) \Delta^{3 / 2} / 4 \\
-\left(4 \mu_{Y} \mu_{Y}^{[1] 2}+4 \mu_{Y}^{2} \mu_{Y}^{[2]}+6 \mu_{Y}^{[1]} \mu_{Y}^{[2]}+4 \mu_{Y} \mu_{Y}^{[3]}+\mu_{Y}^{[4]}\right) \Delta^{5 / 2} / 24\tag{a}</script><p>这里给出第二项的证明，其他项亦然：</p>
<p>泰勒展开(10), $K=3$：</p>
<script type="math/tex; mode=display">
A^{0}f(y_0,y_0)+A^1f(y_{0},y_{0})\Delta + A^{2}f\left( y_0,y_0 \right) \frac{\Delta^{2}} {2!} + A^{3}f\left( y_0,y_0 \right) \frac{\Delta^{3}}{3!} + E[A^{3}f\left( y_{t+\delta},y_0 \right)]\frac{\Delta^{4}}{4!}\tag{a.1}</script><p>每一项计算如下：</p>
<script type="math/tex; mode=display">
A^{0}f\left( y,y_0\right) =H\left(\Delta ^{-\frac {1} {2}}\left( y-y_{0}\right)  \right)|_{y=y_0}=\Delta ^{-\frac {1}{2}}\left( y-y_{0}\right)|_{y=y_0}= 0</script><script type="math/tex; mode=display">
A^{1}f\left( y,y_0\right)  = \mu\Delta ^{-\frac {1} {2}}</script><script type="math/tex; mode=display">
A^2f\left( y,y_0\right) = A(\mu\Delta^{-\frac{1}{2}})=\left(\mu\frac{\partial}{\partial y}(\mu) +\frac{1}{2}\frac{\partial^2}{\partial y^2}(\mu)\right)\Delta^{-\frac{1}{2}} = (\mu\mu^{(1)}+\mu^{(2)})\Delta^{-\frac{1}{2}}</script><script type="math/tex; mode=display">
A^3f\left( y,y_0\right) = A((\mu\mu^{(1)}+\mu^{(2)})\Delta^{-\frac{1}{2}})
    = \left(\mu\frac{\partial}{\partial y}(\mu\mu^{(1)}+\mu^{(2)}) +\frac{1}{2}\frac{\partial^2}{\partial y^2}(\mu\mu^{(1)}+\mu^{(2)})\right)\Delta^{-\frac{1}{2}}
    \\=\frac{1}{2}\Delta^{-\frac{1}{2}}\left(4 \mu_{Y} \mu_{Y}^{[1] 2}+4 \mu_{Y}^{2} \mu_{Y}^{[2]}+6 \mu_{Y}^{[1]} \mu_{Y}^{[2]}+4 \mu_{Y} \mu_{Y}^{[3]}+\mu_{Y}^{[4]}\right)</script><p>带入以上的泰勒展开(a.1)即可得(a).</p>
<p>下面就来到了我头疼了两天的部分，（3）和（4）代入（7），我们会得到</p>
<script type="math/tex; mode=display">
p_{Y}^{(J)}\left(\Delta, y | y_{0} ; \theta\right) \equiv \Delta^{-1 / 2} \phi(\Delta^{-1 / 2}\left(y-y_{0}\right)) \sum_{j=0}^{J} \eta_{Z}^{(j)}\left(\Delta, y_{0} ; \theta\right) H_{j}(\Delta^{-1 / 2}\left(y-y_{0}\right))\tag{11}</script><p>把$\eta_{Z}^{(k,j)}\left(\Delta, y_{0} ; \theta\right)$和$H_j$代入到（11），并且取出$\Delta ^{k}$的所有系数项。便可推导出这篇文章最最最重要的一个结论：</p>
<script type="math/tex; mode=display">
\tilde{p}_{Y}^{(K)}\left(\Delta, y | y_{0} ; \theta\right)=\Delta^{-1 / 2} \phi\left(\frac{y-y_{0}}{\Delta^{1 / 2}}\right) \exp \left(\int_{y_{0}}^{y} \mu_{Y}(w ; \theta) d w\right) \sum_{k=0}^{K} c_{k}\left(y | y_{0} ; \theta\right) \frac{\Delta^{k}}{k !}\tag{12*}</script><p>其中$c_{0}\left(y | y_{0} ; \theta\right)=0$. 其他的项可以通过迭代算出</p>
<script type="math/tex; mode=display">
c_{j}\left(y | y_{0} ; \theta\right)= j\left(y-y_{0}\right)^{-j} \int_{y_{0}}^{y}\left(w-y_{0}\right)^{j-1} \\
 \times\left\{\lambda_{Y}(w ; \theta) c_{j-1}\left(w | y_{0} ; \theta\right)+\left(\partial^{2} c_{j-1}\left(w | y_{0} ; \theta\right) / \partial w^{2}\right) / 2\right\} d w\tag{12.1*}</script><p>其实，我深知直接用（12*）和（12.1*）就可以解决我大部分的问题，但是小编个人天生爱研究（找虐），居然脑补了两天这个是怎么凑出来的，也算是小有所获，但是今天比较晚了（妈妈叫我去喝牛奶），就先写到这里，明天晚上再继续补充这部分的笔记。</p>
<p>参考文献：<br>Maximum-Likelihood Estimation of Discretely-Sampled Diffusions: A Closed-Form Approximation Approach, Econometrica,2002, 70, 223-262 (this paper received the 1998 Cornerstone Research<br>Award)<br>链接：<a href="https://www.princeton.edu/~yacine/mle.pdf" target="_blank" rel="noopener">https://www.princeton.edu/~yacine/mle.pdf</a></p>
<p>结束语：本系列的文章是Yacine大神论文研究的读后感，不得不表达一下自己的崇拜之情，Yacine开源了自己所有的文章和程序，让大家使用和学习。超前的研究，超前的思想，虽然大神的境界不可企及，但是可以膜拜。哈哈，最重要的一点对自己说，从明天开始务正业，务正业！！！</p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Calibration</tag>
      </tags>
  </entry>
  <entry>
    <title>Shecan|蒙特卡罗最小二乘法论文导读</title>
    <url>/2020/02/21/%E7%BE%8E%E5%BC%8F%E6%9C%9F%E6%9D%83%E6%B1%82%E8%A7%A3%EF%BC%9A%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E8%AE%BA%E6%96%87%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="美式期权求解：蒙特卡罗最小二乘法论文导读"><a href="#美式期权求解：蒙特卡罗最小二乘法论文导读" class="headerlink" title="美式期权求解：蒙特卡罗最小二乘法论文导读"></a>美式期权求解：蒙特卡罗最小二乘法论文导读</h1><h2 id="参考论文：Valuing-American-Options-by-Simulation-A-Simple-Least-Squares-Approach"><a href="#参考论文：Valuing-American-Options-by-Simulation-A-Simple-Least-Squares-Approach" class="headerlink" title="参考论文：Valuing American Options by Simulation: A Simple Least-Squares Approach"></a>参考论文：Valuing American Options by Simulation: A Simple Least-Squares Approach</h2><a id="more"></a>
<h2 id="方法原理："><a href="#方法原理：" class="headerlink" title="方法原理："></a>方法原理：</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UCaU6Dop-1639987626597)(C:\Users\Hubu\AppData\Roaming\Typora\typora-user-images\image-20211202175304498.png)]</p>
<p><strong>美式期权的持有者会比较立即执行的支付和继续持有的期望支付。</strong>如果立即执行获得的收益大于继续持有的期望收益的话，就会选择立即执行。这里问题的<strong>核心是如何去估计继续持有的条件期望收益</strong>。文章中所用的办法是最小二乘法。具体来说，就是把已经实现的支付和状态变量来进行回归，从而得到条件期望收益的估计表达式。蒙特卡罗的部分，就是在已知现在的股票价格条件下，模拟未来股票价格的所有可能路径。</p>
<p><img src="https://img-blog.csdnimg.cn/a6f76daf6ccd4963af19478ea4b50d3e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rC054mb6JmrU2hlY2Fu,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<h2 id="执行步骤："><a href="#执行步骤：" class="headerlink" title="执行步骤："></a>执行步骤：</h2><ol>
<li>首先用蒙特卡罗模拟产生一系列的股票路径。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/ccb3b62d49e94731a1811a5f929903dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rC054mb6JmrU2hlY2Fu,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ol>
<li>假设期权没有提前执行。计算到期日的支付情况。(假设执行价格K=1.1)</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/92fdf7f5a78f4c7591a7b91037084c74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rC054mb6JmrU2hlY2Fu,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ol>
<li>然后考虑前一个时间点。这里文章特别的提到只考虑实值期权，这样可以很大的提高计算的效率。把前一个时间点的实值期权对应的未来支付进行折现。然后对状态变量做回归。得到的回归表达式即是对继续持有期权的期望收益的估计。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/3830e43f823a4b5aa315a1ebe5eef414.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rC054mb6JmrU2hlY2Fu,size_9,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>文中给出只考虑实值期权的原因是只有实值期权才能够做执行与持有的这个决策。</p>
<ol>
<li>$Y$ 是下一期期望支付的折现值。 X是当期的状态变量价格。 Y对X做回归可以得到以下的表达式:</li>
</ol>
<script type="math/tex; mode=display">
E[Y \mid X]=-1.070+2.983 X-1.813 X^{2}\tag{1}</script><p>注意，这里只选择第二期的实值期权。文中指出，$\{1,X,X^2\}$ 不是唯一的回归变量的选择，还可以选择$L^2$空间上的正交基如Laguerre多项式，Legender多项式，Hermite多项式等等。</p>
<ol>
<li>计算出来的条件期望(1)可以作为继续持有的期望收益的估计， 对比立即执行的收益和刚才所求得的继续持有的期望收益。如果立即执行的收益大于继续持有的期望收益，选择立即执行，否则我们将继续持有到到期日。如下图所示：</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/fe8067629d7a46dba69016f6257a6914.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rC054mb6JmrU2hlY2Fu,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<ol>
<li><p>通过以上的判断，更新当期收益，得到新的现金流之后，重复以上两个步骤，直到时间点t=1。</p>
</li>
<li><p>最后，把t=1时间点的期权价值折现到t=0时间点，并求平均。</p>
<p>具体的流程如下所示：</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/7cd5be2dcd2d4204b578e4437cf1ca69.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rC054mb6JmrU2hlY2Fu,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>一个比较好面向对象的python代码：<a href="https://github.com/ngokchaoho/Least-Square-Monte-Carlo/blob/main/Least%20Square%20Monte%20Carlo%20Implementation%20in%20a%20Python%20Class.ipynb" target="_blank" rel="noopener">https://github.com/ngokchaoho/Least-Square-Monte-Carlo/blob/main/Least%20Square%20Monte%20Carlo%20Implementation%20in%20a%20Python%20Class.ipynb</a></p>
<p>插入一个小小的话题，理论上，不支付红利的条件下，美式看涨期权为何不会提前行权？</p>
<p>美式期权的价值$C$大于欧式期权的价值$c$（C=c+early exercise premium），根据平价公式$c=(S-k)+(k-k<em>exp(-r</em>t))+p$，即是说$C&gt;=c&gt;=S-k$。美式期权在到期日之前的价值大于立即执行的价值，因而，一般情况下，不支付红利的美式期权不会提前行权。</p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
