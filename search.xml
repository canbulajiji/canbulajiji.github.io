<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Shecan|单变量随机扩散过程的参数估计——Hermite近似笔记似然函数</title>
    <url>/2020/02/21/python%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为何要进行版本控制？对我来说因为运行一些程序发现了版本不兼容的问题，特别是运行一些开源的软件。所以记下来自己控制版本的过程，避免以后重复搜索，浪费时间。</p>
<a id="more"></a>
<ol>
<li><h6 id="cmd-中的版本控制"><a href="#cmd-中的版本控制" class="headerlink" title="cmd 中的版本控制"></a>cmd 中的版本控制</h6><p>需求：每次在cmd中运行 python 的时候启动 python 3.8， 每次在cmd中运行python2的时候启动 python 2.7, 输入 python3 的时候运行 python 3.8. 如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200322202943200.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>第三个python使我之前装的anaconda 3带的版本。</p>
<p>实现以上效果的具体配置如下：</p>
<p>Step 1. Install Python 3.8 and Python 2.7 from <a href="https://www.python.org/downloads/，use" target="_blank" rel="noopener">https://www.python.org/downloads/，use</a> all the default settings. 安装过程中 <strong>注意不要勾选加入到path</strong>, 需要手动加入。或者喜欢anaconda的同学可以从这个网站下载 <a href="https://www.anaconda.com/distribution/，配置方法类似。" target="_blank" rel="noopener">https://www.anaconda.com/distribution/，配置方法类似。</a></p>
<p>Step 2. Find the destination directory of your python files and change the name as below:</p>
<p>找到Python 2.7 的安装目录，把 python 改成  python2。找到Python 3.8 的安装目录，把python 改成 python3 如图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200322203112114.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/2020032220321681.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>   Step 3. 把 Python 3.7 和 python 2.7 加入到环境变量，如图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200322203244966.PNG#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><h6 id="Version-Control-in-Jupyter-lab"><a href="#Version-Control-in-Jupyter-lab" class="headerlink" title="Version Control in Jupyter lab."></a>Version Control in Jupyter lab.</h6><p>需求：如图所示，在Jupyter lab中可以随意切换版本。</p>
<p><img src="https://img-blog.csdnimg.cn/2020032220332038.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>或在运行某一个程序时，也可以随时切换Kernel.</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200322203424793.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>   可以看出R也是可以加入kernel的，这是我以前配置的，但对R来说还是Rstudio比较习惯，配置好了也没用过，所以大家有需要可以自行搜索一下。</p>
<p>   如果是anaconda的用户，在 cmd 中连续输入以下的命令即可</p>
   <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">conda create <span class="literal">-n</span> py27 python=<span class="number">2.7</span></span><br><span class="line">conda activate py27</span><br><span class="line">conda install notebook ipykernel</span><br><span class="line">ipython kernel install -<span class="literal">-user</span></span><br></pre></td></tr></table></figure>
<p>   如果不用 conda, 可以用以下的命令</p>
   <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python2 <span class="literal">-m</span> pip install ipykernel</span><br><span class="line"></span><br><span class="line">python2 <span class="literal">-m</span> ipykernel install -<span class="literal">-user</span></span><br></pre></td></tr></table></figure>
<p>​       参考链接：<a href="https://stackoverflow.com/questions/30492623/using-both-python-2-x-and-python-3-x-in-ipython-notebook" target="_blank" rel="noopener">https://stackoverflow.com/questions/30492623/using-both-python-2-x-and-python-3-x-in-ipython-notebook</a></p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Calibration</tag>
      </tags>
  </entry>
  <entry>
    <title>Shecan|Monte Carlo Simulation for CIR Process</title>
    <url>/2020/02/21/Monte%20Carlo%20Simulation%20for%20CIR%20Process/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Monte-Carlo-Simulation-for-CIR-Process"><a href="#Monte-Carlo-Simulation-for-CIR-Process" class="headerlink" title="Monte Carlo Simulation for CIR Process"></a>Monte Carlo Simulation for CIR Process</h1><p>(To be continued ……)</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Two models are commonly applied to describe the stochastic interest rate process (or the stochastic volatility process), including the OU process and the CIR process.</p>
<a id="more"></a>
<ul>
<li>The OU process:</li>
</ul>
<script type="math/tex; mode=display">
d r_{t}=\alpha\left(\mu-r_{t}\right) d t+\sigma d W_{t}\tag{1}</script><ul>
<li>The CIR process:</li>
</ul>
<script type="math/tex; mode=display">
d r_{t}=\alpha\left(\mu-r_{t}\right) d t+\sigma \sqrt{r_{t}} d W_{t}\tag{2}</script><p>where $\mu$ is the mean reversion level and $\alpha$ is the mean reversion speed.</p>
<p>Both of the models are mean-reverted, however, the OU process cannot ensure the nonnegativity of the interest rate. The OU process is driven by a normal distribution, but the underlying distribution of the CIR process is a non-central Chi-square distribution. </p>
<h2 id="Monte-Carlo-Simulation"><a href="#Monte-Carlo-Simulation" class="headerlink" title="Monte Carlo Simulation"></a>Monte Carlo Simulation</h2><p>Two methods are commonly applied to simulate the stochastic process, including the <strong>Euler–Maruyama Method</strong> and the <strong>Milstein Method</strong>. The differences between the two methods are the way of discretization and the order of convergence. The preliminary knowledge of the two discretization is the Ito Taylor expansion (For deriving details, please refer to the reference ‘Ito Taylor Expansion’). </p>
<script type="math/tex; mode=display">
X\left(t_{i+1}\right)=X\left(t_{i}\right)+a\left[X\left(t_{i}\right)\right] \Delta t+b\left[X\left(t_{i}\right)\right] \Delta W_{i}+\frac{1}{2} b\left[X\left(t_{i}\right)\right] b^{\prime}\left[X\left(t_{i}\right)\right]\left[\left(\Delta W_{i}\right)^{2}-\Delta t\right]+\mathcal{O}(\Delta t)</script><p>The Euler-Maruyama method is the first-order truncation of the Ito Taylor expansion and the Milstein Method is the second-order truncation of the Ito Taylor expansion. </p>
<p>Specifically, for the CIR process, we have $a[r] = \alpha(\mu - r)$, $b[r]=\sigma\sqrt{r}$, and $b’[r]=\frac{1}{2}\frac{\sigma}{\sqrt{r}}$.</p>
<ul>
<li>The Euler-Maruyama Method:</li>
</ul>
<script type="math/tex; mode=display">
r_{j}=r_{j-1}+\alpha\left(\mu - r_{j-1}\right) \Delta t+\sigma\sqrt{r_{j-1}}\Delta W_j, \quad j=1,2, \ldots, L</script><p>where $\Delta W_j = \sqrt{\Delta t}N(1,0)$.</p>
<ul>
<li>The Milstein Method:</li>
</ul>
<script type="math/tex; mode=display">
r_{j}=r_{j-1}+\alpha\left(\mu - r_{j-1}\right) \Delta t+\sigma\sqrt{r_{j-1}}\Delta W_j+\frac{\sigma^2}{2}[(\Delta W_j)^2-\Delta t], \quad j=1,2, \ldots, L</script><p>The weak and strong convergence rate of Euler-Maruyama are $\mathcal{}$$\mathcal{O}(\Delta t)$. The Milstein scheme has the same weak convergence but better strong convergence rate of $\mathcal{O}(\sqrt{\Delta t)}$. The detail definition of the weak and the strong convergence rate refer to <em>Higham (2001).</em></p>
<h2 id="Python-Code"><a href="#Python-Code" class="headerlink" title="Python Code"></a>Python Code</h2><p>For further extension, I wrote a class file first.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Wed Feb 26 22:42:55 2020</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Shecan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">please save the file as CIR.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CIR</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, alpha, mu, sigma, r0)</span>:</span></span><br><span class="line">         self.alpha = alpha <span class="comment"># mean-reverted speed</span></span><br><span class="line">         self.mu = mu <span class="comment"># mean-reverted level</span></span><br><span class="line">         self.sigma = sigma <span class="comment"># vol of interest rate</span></span><br><span class="line">         self.r0 = r0 <span class="comment"># initial interest rate</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Euler</span><span class="params">(self,t_init,t_end,dt)</span>:</span></span><br><span class="line">        np.random.seed(<span class="number">5</span>)</span><br><span class="line">        ts = np.arange(t_init, t_end, dt)</span><br><span class="line">        dW = np.random.normal(loc=<span class="number">0.0</span>, scale=np.sqrt(dt),size = ts.size)</span><br><span class="line">        r = []</span><br><span class="line">        r.append(self.r0)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, ts.size):</span><br><span class="line">            r.append(r[i<span class="number">-1</span>] + self.alpha*(self.mu-r[i<span class="number">-1</span>])*dt </span><br><span class="line">                     + self.sigma*np.sqrt(r[i<span class="number">-1</span>])*dW[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Milstein</span><span class="params">(self,t_init,t_end,dt)</span>:</span></span><br><span class="line">        np.random.seed(<span class="number">5</span>)</span><br><span class="line">        ts = np.arange(t_init, t_end, dt)</span><br><span class="line">        dW = np.random.normal(loc=<span class="number">0.0</span>, scale=np.sqrt(dt),size = ts.size)</span><br><span class="line">        r = []</span><br><span class="line">        r.append(self.r0)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, ts.size):</span><br><span class="line">            dw = dW[i<span class="number">-1</span>]</span><br><span class="line">            r.append(r[i<span class="number">-1</span>] + self.alpha*(self.mu-r[i<span class="number">-1</span>])*dt </span><br><span class="line">                     + self.sigma*np.sqrt(r[i<span class="number">-1</span>])*dw + </span><br><span class="line">                     (self.sigma**<span class="number">2</span>/<span class="number">2</span>)*(dw**<span class="number">2</span> - dt))</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>Then we can load the class file in Jupyter notebook, </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> CIR <span class="keyword">import</span> CIR <span class="comment"># from the module CIR load our class-file CIR</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># assume mean-reverted speed = 1, mean-reverted level = 0.05, vol of interest rate = 0.05, initial interest rate = 0.05, and pass to an object named C </span></span><br><span class="line">C = CIR(<span class="number">1</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0.05</span>)</span><br><span class="line"><span class="comment"># For Euler method</span></span><br><span class="line">r = C.Euler(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.001</span>) <span class="comment"># start time = 0, end time = 1, dt = 0.01</span></span><br><span class="line"><span class="comment"># For Milstern method</span></span><br><span class="line">r1 = C.Milstein(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.001</span>)</span><br><span class="line"><span class="comment"># Plot and compare</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">l1,=plt.plot(r)</span><br><span class="line">l2,=plt.plot(r1,<span class="string">'b*'</span>,markersize=<span class="number">4</span>)</span><br><span class="line">plt.ylabel(<span class="string">'interest rate r'</span>,fontsize = <span class="number">20</span>)</span><br><span class="line">plt.legend(handles=[l1, l2], labels=[<span class="string">'Euler'</span>, <span class="string">'Milstein'</span>], fontsize = <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>Visualizing the results:</p>
<p><img src="https://img-blog.csdnimg.cn/20200303225854819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70" alt="Monte Carlo Simulation"></p>
<h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p>CIR Modeling of Interest Rates</p>
<p><a href="http://lnu.diva-portal.org/smash/get/diva2:1270329/FULLTEXT01.pdf" target="_blank" rel="noopener">http://lnu.diva-portal.org/smash/get/diva2:1270329/FULLTEXT01.pdf</a></p>
<p>Enlightened reading material</p>
<p><em>Higham, D. J. (2001). An algorithmic introduction to numerical simulation of stochastic differential equations. SIAM review, 43(3), 525-546.</em></p>
<p>Ito-Taylor Expansion</p>
<p><a href="https://www.math.nyu.edu/~cai/Courses/Derivatives/compfin_lecture_5.pdf" target="_blank" rel="noopener">https://www.math.nyu.edu/~cai/Courses/Derivatives/compfin_lecture_5.pdf</a></p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>Shecan|单变量随机扩散过程的参数估计——Hermite近似笔记似然函数</title>
    <url>/2020/02/21/%E5%8D%95%E5%8F%98%E9%87%8F%E9%9A%8F%E6%9C%BA%E6%89%A9%E6%95%A3%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1%E2%80%94%E2%80%94Hermite%E5%BA%8F%E5%88%97%E8%BF%91%E4%BC%BC%E4%BC%B0%E8%AE%A1%E8%BD%AC%E7%A7%BB%E5%AF%86%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单变量随机扩散过程的参数估计——Hermite序列近似估计转移密度</p>
<p>这篇博文基于作者个人最近阅读Yacine（2002）年的一篇很经典的论文的理解。这篇文章比较牛逼之处在于可以通过Hermite序列近似估计出转移概率密度（regardless the underlying distribution），从而得到一个外生得似然函数。并且可以扩展到多维的随机过程。</p>
<p>(未完待续 ……)<br><a id="more"></a><br>虽然Yacine公开了程序，但是作者最近求知欲爆棚（比较无聊），所以记下自己的理解和自己猜测的一些推导细节。当然，刚开始学习，理解还浮于表面，如果有不到位的地方，希望路过的大牛能够指出。</p>
<p>对于一个一般的扩散过程：</p>
<script type="math/tex; mode=display">
d \boldsymbol{X}_{t}=\mu\left(\boldsymbol{X}_{t} ; \boldsymbol{\theta}\right) d t+\sigma\left(\boldsymbol{X}_{t} ; \boldsymbol{\theta}\right) d \boldsymbol{W}_{t}\tag{1}</script><p>比如说CIR过程：</p>
<script type="math/tex; mode=display">
d x_{t}=\alpha\left(\mu-x_{t}\right) d t+\sigma \sqrt{x_{t}} d W_{t}\tag{1*}</script><p>从作者的上一篇博文可知，CIR过程服从非中心卡方分布，转移概率计算相当复杂。但是通过一系列的变换，Yacine让以上的过程更加近似于正态分布，从而可以用Hermite序列来近似估计正态分布函数。这个变换就是一个从X到Z的过程。得到Z过程的近似转移概率后，我们可以倒推到X过程，从而推出外生的似然函数，最终目标如下：</p>
<script type="math/tex; mode=display">
\ell_{n}(\theta) \equiv \sum_{i=1}^{n} \ln \left\{p_{X}\left(\Delta, X_{i \Delta} | X_{(i-1) \Delta} ; \theta\right)\right\}\tag{**}</script><p>通过似然函数的最优化，即可以对未知参数进行估计。具体的变化过程如下：</p>
<p>第一步， 标准化，去除方差的影响。 $(X\rightarrow Y)$</p>
<script type="math/tex; mode=display">
Y \equiv \gamma(X ; \theta)=\int^{x} d u / \sigma(u ; \theta)\tag{2}</script><p>带入Ito公式</p>
<script type="math/tex; mode=display">
\begin{aligned}
&d Y_{s}=\mu_{Y}\left(Y_{t} ; \theta\right) d t+d W_{t}, \quad \text { where }\\
&\mu_{Y}(y ; \theta)=\frac{\mu\left(\gamma^{-1}(y ; \theta) ; \theta\right)}{\sigma\left(\gamma^{-1}(y ; \theta) ; \theta\right)}-\frac{1}{2} \frac{\partial \sigma}{\partial x}\left(\gamma^{-1}(y ; \theta) ; \theta\right)
\end{aligned}</script><p>第二步， 中心化，去除尖峰影响。$(Y\rightarrow Z)$</p>
<script type="math/tex; mode=display">
Z \equiv \Delta^{-1 / 2}\left(Y-y_{0}\right)\tag{3}</script><p>第三步，利用Hermite序列近似逼近Z的转移概率密度：</p>
<script type="math/tex; mode=display">
p_{Z}^{(J)}\left(\Delta, z | y_{0} ; \theta\right) \equiv \phi(z) \sum_{j=0}^{J} \eta_{Z}^{(j)}\left(\Delta, y_{0} ; \theta\right) H_{j}(z)\tag{4}</script><p>其中$\phi(z) \equiv e^{-z^{2} / 2} / \sqrt{2 \pi}$, 是标准的正态分布密度函数。而</p>
<script type="math/tex; mode=display">
H_{j}(z) \equiv e^{z^{2} / 2} \frac{d^{j}}{d z^{j}}\left[e^{-z^{2} / 2}\right], \quad j \geq 0\tag{5}</script><p>是标准的Hermite序列。系数项可以如下的积分过程得到</p>
<script type="math/tex; mode=display">
\eta_{Z}^{(j)}\left(\Delta, y_{0} ; \theta\right) \equiv(1 / j !) \int_{-\infty}^{+\infty} H_{j}(z) p_{Z}\left(\Delta, z | y_{0} ; \theta\right) d z\tag{6}</script><p>这里我想可以近似于傅里叶逼近来理解，毕竟Hermite序列也是正交序列。所以证明方法应该和傅里叶序列函数逼近差不多，因而我目前还不是特别好奇。</p>
<p>第四步，已知Z的状态转移密度，求Y的状态转移密度：$(Z\rightarrow Y)$</p>
<p>根据（3）和（4）：</p>
<script type="math/tex; mode=display">
p_{Y}^{(J)}\left(\Delta, y | y_{0} ; \theta\right) \equiv \Delta^{-1 / 2} p_{Z}^{(J)}\left(\Delta, \Delta^{-1 / 2}\left(y-y_{0}\right) | y_{0} ; \theta\right)\tag{7}</script><p>第五步，已知Y的转移密度，得到X的转移密度：$(Z\rightarrow Y)$</p>
<script type="math/tex; mode=display">
p_{X}^{(J)}\left(\Delta, x | x_{0} ; \theta\right) \equiv \sigma(x ; \theta)^{-1} p_{Y}^{(J)}\left(\Delta, \gamma(x, \theta) | \gamma\left(x_{0} ; \theta\right) ; \theta\right)\tag{8}</script><p>第六步，最大化似然函数（**）。</p>
<p>以上即为Yacine似然估计的整个流程，而这里最重要也最复杂的就是第三步，如何通过序列逼近$p_{Z}^{(J)}\left(\Delta, z | y_{0} ; \theta\right)$</p>
<p>通过较为简单的变量替换，我们有如下的结果</p>
<script type="math/tex; mode=display">
\begin{aligned}
\eta_{Z}^{(j)}\left(\Delta, y_{0} ; \theta\right) &=(1 / j !) \int_{-\infty}^{+\infty} H_{j}(z) p_{Z}\left(\Delta, z | y_{0} ; \theta\right) d z \\
&=(1 / j !) \int_{-\infty}^{+\infty} H_{j}(z) \Delta^{1 / 2} p_{Y}\left(\Delta, \Delta^{1 / 2} z+y_{0} | y_{0} ; \theta\right) d z \\
&=(1 / j !) \int_{-\infty}^{+\infty} H_{j}\left(\Delta^{-1 / 2}\left(y-y_{0}\right)\right) p_{Y}\left(\Delta, y | y_{0} ; \theta\right) d y \\
&=(1 / j !) E\left[H_{j}\left(\Delta^{-1 / 2}\left(Y_{t+\Delta}-y_{0}\right)\right) | Y_{t}=y_{0} ; \theta\right]
\end{aligned}</script><p>这里，第二行的推导参照（7），可以反解出：</p>
<script type="math/tex; mode=display">
p_{Z}\left(\Delta, z | y_{0} ; \theta\right)=\Delta^{1 / 2} p_{Y}\left(\Delta, \Delta^{1 / 2} z+y_{0} | y_{0} ; \theta\right)\tag{9}</script><p>第三行带入（3）即可。最后一行是期望的定义。然后最后一行的期望项用Tarlor公式展开:</p>
<script type="math/tex; mode=display">
E\left[f\left(Y_{t+\Delta}, y_{0}\right) | Y_{t}=y_{0}\right]= \sum_{k=0}^{K} A^{k}(\theta) \cdot f\left(y_{0}, y_{0}\right) \frac{\Delta^{k}}{k !} \\
+E\left[A^{K+1}(\theta) \cdot f\left(Y_{t+\delta}, y_{0}\right) | Y_{t}=y_{0}\right] \frac{\Delta^{K+1}}{(K+1) !}\tag{10}</script><p>这里 $f\left(y, y_{0}\right)=H_{j}\left(\Delta^{-1 / 2}\left(Y_{t+\Delta}-y_{0}\right)\right)$. 通过定义 （5），我们展开前七项的Hermite序列</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$H_0(z)$</th>
<th style="text-align:center">1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$H_1(z)$</td>
<td style="text-align:center">-x</td>
</tr>
<tr>
<td style="text-align:center">$H_2(z)$</td>
<td style="text-align:center">$x^2-1$</td>
</tr>
<tr>
<td style="text-align:center">$H_3(z)$</td>
<td style="text-align:center">$-x^3+3x$</td>
</tr>
<tr>
<td style="text-align:center">$H_4(z)$</td>
<td style="text-align:center">$x^4-6x^2+3$</td>
</tr>
<tr>
<td style="text-align:center">$H_5(z)$</td>
<td style="text-align:center">$-x^5+10x^3-15x$</td>
</tr>
<tr>
<td style="text-align:center">$H_6(z)$</td>
<td style="text-align:center">$x^6-15x^4+45x^2-15$</td>
</tr>
</tbody>
</table>
</div>
<p>而算子$A = \mu_y\frac{\partial}{\partial y} +\frac{1}{2}\frac{\partial^2}{\partial y^2}$。这里$\eta_{Z}^{(k,j)}\left(\Delta, y_{0} ; \theta\right)$有两个上标， k表示泰勒展开的阶数，j代表Hermite序列的阶数。Yacine在文章中给出了前七项的表达式，如图</p>
<p><img src="C:\Users\Hubu\Desktop\草稿\hermite.png" alt=""></p>
<p>还有第一项$\eta^{(0,3)}_Z=1$;</p>
<script type="math/tex; mode=display">
\eta_{Z}^{(1,3)}=-\mu_{Y} \Delta^{1 / 2}-\left(2 \mu_{Y} \mu_{Y}^{[1]}+\mu_{Y}^{[2]}\right) \Delta^{3 / 2} / 4 \\
-\left(4 \mu_{Y} \mu_{Y}^{[1] 2}+4 \mu_{Y}^{2} \mu_{Y}^{[2]}+6 \mu_{Y}^{[1]} \mu_{Y}^{[2]}+4 \mu_{Y} \mu_{Y}^{[3]}+\mu_{Y}^{[4]}\right) \Delta^{5 / 2} / 24\tag{a}</script><p>这里给出第二项的证明，其他项亦然：</p>
<p>泰勒展开(10), $K=3$：</p>
<script type="math/tex; mode=display">
A^{0}f(y_0,y_0)+A^1f(y_{0},y_{0})\Delta + A^{2}f\left( y_0,y_0 \right) \frac{\Delta^{2}} {2!} + A^{3}f\left( y_0,y_0 \right) \frac{\Delta^{3}}{3!} + E[A^{3}f\left( y_{t+\delta},y_0 \right)]\frac{\Delta^{4}}{4!}\tag{a.1}</script><p>每一项计算如下：</p>
<script type="math/tex; mode=display">
A^{0}f\left( y,y_0\right) =H\left(\Delta ^{-\frac {1} {2}}\left( y-y_{0}\right)  \right)|_{y=y_0}=\Delta ^{-\frac {1}{2}}\left( y-y_{0}\right)|_{y=y_0}= 0</script><script type="math/tex; mode=display">
A^{1}f\left( y,y_0\right)  = \mu\Delta ^{-\frac {1} {2}}</script><script type="math/tex; mode=display">
A^2f\left( y,y_0\right) = A(\mu\Delta^{-\frac{1}{2}})=\left(\mu\frac{\partial}{\partial y}(\mu) +\frac{1}{2}\frac{\partial^2}{\partial y^2}(\mu)\right)\Delta^{-\frac{1}{2}} = (\mu\mu^{(1)}+\mu^{(2)})\Delta^{-\frac{1}{2}}</script><script type="math/tex; mode=display">
A^3f\left( y,y_0\right) = A((\mu\mu^{(1)}+\mu^{(2)})\Delta^{-\frac{1}{2}})
    = \left(\mu\frac{\partial}{\partial y}(\mu\mu^{(1)}+\mu^{(2)}) +\frac{1}{2}\frac{\partial^2}{\partial y^2}(\mu\mu^{(1)}+\mu^{(2)})\right)\Delta^{-\frac{1}{2}}
    \\=\frac{1}{2}\Delta^{-\frac{1}{2}}\left(4 \mu_{Y} \mu_{Y}^{[1] 2}+4 \mu_{Y}^{2} \mu_{Y}^{[2]}+6 \mu_{Y}^{[1]} \mu_{Y}^{[2]}+4 \mu_{Y} \mu_{Y}^{[3]}+\mu_{Y}^{[4]}\right)</script><p>带入以上的泰勒展开(a.1)即可得(a).</p>
<p>下面就来到了我头疼了两天的部分，（3）和（4）代入（7），我们会得到</p>
<script type="math/tex; mode=display">
p_{Y}^{(J)}\left(\Delta, y | y_{0} ; \theta\right) \equiv \Delta^{-1 / 2} \phi(\Delta^{-1 / 2}\left(y-y_{0}\right)) \sum_{j=0}^{J} \eta_{Z}^{(j)}\left(\Delta, y_{0} ; \theta\right) H_{j}(\Delta^{-1 / 2}\left(y-y_{0}\right))\tag{11}</script><p>把$\eta_{Z}^{(k,j)}\left(\Delta, y_{0} ; \theta\right)$和$H_j$代入到（11），并且取出$\Delta ^{k}$的所有系数项。便可推导出这篇文章最最最重要的一个结论：</p>
<script type="math/tex; mode=display">
\tilde{p}_{Y}^{(K)}\left(\Delta, y | y_{0} ; \theta\right)=\Delta^{-1 / 2} \phi\left(\frac{y-y_{0}}{\Delta^{1 / 2}}\right) \exp \left(\int_{y_{0}}^{y} \mu_{Y}(w ; \theta) d w\right) \sum_{k=0}^{K} c_{k}\left(y | y_{0} ; \theta\right) \frac{\Delta^{k}}{k !}\tag{12*}</script><p>其中$c_{0}\left(y | y_{0} ; \theta\right)=0$. 其他的项可以通过迭代算出</p>
<script type="math/tex; mode=display">
c_{j}\left(y | y_{0} ; \theta\right)= j\left(y-y_{0}\right)^{-j} \int_{y_{0}}^{y}\left(w-y_{0}\right)^{j-1} \\
 \times\left\{\lambda_{Y}(w ; \theta) c_{j-1}\left(w | y_{0} ; \theta\right)+\left(\partial^{2} c_{j-1}\left(w | y_{0} ; \theta\right) / \partial w^{2}\right) / 2\right\} d w\tag{12.1*}</script><p>其实，我深知直接用（12*）和（12.1*）就可以解决我大部分的问题，但是小编个人天生爱研究（找虐），居然脑补了两天这个是怎么凑出来的，也算是小有所获，但是今天比较晚了（妈妈叫我去喝牛奶），就先写到这里，明天晚上再继续补充这部分的笔记。</p>
<p>参考文献：<br>Maximum-Likelihood Estimation of Discretely-Sampled Diffusions: A Closed-Form Approximation Approach, Econometrica,2002, 70, 223-262 (this paper received the 1998 Cornerstone Research<br>Award)<br>链接：<a href="https://www.princeton.edu/~yacine/mle.pdf" target="_blank" rel="noopener">https://www.princeton.edu/~yacine/mle.pdf</a></p>
<p>结束语：本系列的文章是Yacine大神论文研究的读后感，不得不表达一下自己的崇拜之情，Yacine开源了自己所有的文章和程序，让大家使用和学习。超前的研究，超前的思想，虽然大神的境界不可企及，但是可以膜拜。哈哈，最重要的一点对自己说，从明天开始务正业，务正业！！！</p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Calibration</tag>
      </tags>
  </entry>
  <entry>
    <title>Shecan|CIR过程蒙特卡洛模拟</title>
    <url>/2020/02/21/CIR%E8%BF%87%E7%A8%8B%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CIR过程蒙特卡洛模拟"><a href="#CIR过程蒙特卡洛模拟" class="headerlink" title="CIR过程蒙特卡洛模拟"></a>CIR过程蒙特卡洛模拟</h1><p>众所周知，利率是随着时间的变化而随机变化的，本文简要说明了两种常用的随机利率过程，并基于Python用蒙特卡洛的方法模拟出随机利率过程。</p>
<p>(未完待续 ……)<br><a id="more"></a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>最常用的随机利率模型包括：OU 过程和 CIR 过程：</p>
<ul>
<li>The OU process:</li>
</ul>
<script type="math/tex; mode=display">
d r_{t}=\alpha\left(\mu-r_{t}\right) d t+\sigma d W_{t}\tag{1}</script><ul>
<li>The CIR process:</li>
</ul>
<script type="math/tex; mode=display">
d r_{t}=\alpha\left(\mu-r_{t}\right) d t+\sigma \sqrt{r_{t}} d W_{t}\tag{2}</script><p>where $\mu$ 是均值回归的水平 and $\alpha$ 是均值回归的速度。</p>
<p>利率虽然是随机的，但不会长久偏离均值水平，因而是均值回归的。OU 过程服从正态分布，而 CIR 过程服从一个非中心的卡方分布（具体可以看维基上的说明）。CIR 过程优于OU过程之处在于， 可以保证利率的非负性</p>
<h2 id="Monte-Carlo-Simulation"><a href="#Monte-Carlo-Simulation" class="headerlink" title="Monte Carlo Simulation"></a>Monte Carlo Simulation</h2><p>对于以上两个随机过程的离散，通常有两种方法： <strong>Euler–Maruyama Method</strong> and the <strong>Milstein Method</strong>。和一般的不带随机变量的差分相似，两种方法的区别在于在不同的地方对泰勒展开公式进行截断，然而由于随机项的引入，我们需要用Ito-Taylor对其进行展开（具体的推导，我找到的最清楚（读得懂）的证明即参考文献中的’Ito Taylor Expansion’）。</p>
<script type="math/tex; mode=display">
X\left(t_{i+1}\right)=X\left(t_{i}\right)+a\left[X\left(t_{i}\right)\right] \Delta t+b\left[X\left(t_{i}\right)\right] \Delta W_{i}+\frac{1}{2} b\left[X\left(t_{i}\right)\right] b^{\prime}\left[X\left(t_{i}\right)\right]\left[\left(\Delta W_{i}\right)^{2}-\Delta t\right]+\mathcal{O}(\Delta t)</script><p>如上所示， Euler-Maruyama 是对上式的一阶截断， 而 Milstein 是对上式的二阶截断。这里的$\mathcal{O}$ 表示剩余的项是</p>
<p>$\Delta t$ 的高阶项。</p>
<p>因而，我们有以下的两个离散表达式：</p>
<p>Specifically, for the CIR process, we have $a[r] = \alpha(\mu - r)$, $b[r]=\sigma\sqrt{r}$, and $b’[r]=\frac{1}{2}\frac{\sigma}{\sqrt{r}}$.</p>
<ul>
<li>The Euler-Maruyama Method:</li>
</ul>
<script type="math/tex; mode=display">
r_{j}=r_{j-1}+\alpha\left(\mu - r_{j-1}\right) \Delta t+\sigma\sqrt{r_{j-1}}\Delta W_j, \quad j=1,2, \ldots, L</script><p>where $\Delta W_j = \sqrt{\Delta t}N(1,0)$.</p>
<ul>
<li>The Milstein Method:</li>
</ul>
<script type="math/tex; mode=display">
r_{j}=r_{j-1}+\alpha\left(\mu - r_{j-1}\right) \Delta t+\sigma\sqrt{r_{j-1}}\Delta W_j+\frac{\sigma^2}{2}[(\Delta W_j)^2-\Delta t], \quad j=1,2, \ldots, L</script><p>The weak and strong convergence rate of Euler-Maruyama are $\mathcal{}$$\mathcal{O}(\Delta t)$. The Milstein scheme has the same weak convergence but better strong convergence rate of $\mathcal{O}(\sqrt{\Delta t)}$. The detail definition of the weak and the strong convergence rate refer to <em>Higham (2001).</em> （这篇文章是我一个师兄推荐给我的，我学习蒙特卡洛模拟也是从这篇文章开始的，后来有个刚读博士的泰国美女询问我如何做随机过程的蒙特卡洛模拟时，我也把这篇文章推荐给了她，分享使我们快乐。）</p>
<h2 id="Python-Code"><a href="#Python-Code" class="headerlink" title="Python Code"></a>Python Code</h2><p>因为我觉得以后有时间可以在这个问题上玩出朵花来，所以我先写了一个类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Wed Feb 26 22:42:55 2020</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Shecan</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">please save the file as CIR.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CIR</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, alpha, mu, sigma, r0)</span>:</span></span><br><span class="line">         self.alpha = alpha <span class="comment"># mean-reverted speed</span></span><br><span class="line">         self.mu = mu <span class="comment"># mean-reverted level</span></span><br><span class="line">         self.sigma = sigma <span class="comment"># vol of interest rate</span></span><br><span class="line">         self.r0 = r0 <span class="comment"># initial interest rate</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Euler</span><span class="params">(self,t_init,t_end,dt)</span>:</span></span><br><span class="line">        np.random.seed(<span class="number">5</span>)</span><br><span class="line">        ts = np.arange(t_init, t_end, dt)</span><br><span class="line">        dW = np.random.normal(loc=<span class="number">0.0</span>, scale=np.sqrt(dt),size = ts.size)</span><br><span class="line">        r = []</span><br><span class="line">        r.append(self.r0)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, ts.size):</span><br><span class="line">            r.append(r[i<span class="number">-1</span>] + self.alpha*(self.mu-r[i<span class="number">-1</span>])*dt </span><br><span class="line">                     + self.sigma*np.sqrt(r[i<span class="number">-1</span>])*dW[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Milstein</span><span class="params">(self,t_init,t_end,dt)</span>:</span></span><br><span class="line">        np.random.seed(<span class="number">5</span>)</span><br><span class="line">        ts = np.arange(t_init, t_end, dt)</span><br><span class="line">        dW = np.random.normal(loc=<span class="number">0.0</span>, scale=np.sqrt(dt),size = ts.size)</span><br><span class="line">        r = []</span><br><span class="line">        r.append(self.r0)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, ts.size):</span><br><span class="line">            dw = dW[i<span class="number">-1</span>]</span><br><span class="line">            r.append(r[i<span class="number">-1</span>] + self.alpha*(self.mu-r[i<span class="number">-1</span>])*dt </span><br><span class="line">                     + self.sigma*np.sqrt(r[i<span class="number">-1</span>])*dw + </span><br><span class="line">                     (self.sigma**<span class="number">2</span>/<span class="number">2</span>)*(dw**<span class="number">2</span> - dt))</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>然后我们在 Jupyter notebook中调用以上的类, </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> CIR <span class="keyword">import</span> CIR <span class="comment"># from the module CIR load our class-file CIR</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># assume mean-reverted speed = 1, mean-reverted level = 0.05, vol of interest rate = 0.05, initial interest rate = 0.05, and pass to an object named C </span></span><br><span class="line">C = CIR(<span class="number">1</span>,<span class="number">0.05</span>,<span class="number">0.05</span>,<span class="number">0.05</span>)</span><br><span class="line"><span class="comment"># For Euler method</span></span><br><span class="line">r = C.Euler(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.001</span>) <span class="comment"># start time = 0, end time = 1, dt = 0.01</span></span><br><span class="line"><span class="comment"># For Milstern method</span></span><br><span class="line">r1 = C.Milstein(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.001</span>)</span><br><span class="line"><span class="comment"># Plot and compare</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">l1,=plt.plot(r)</span><br><span class="line">l2,=plt.plot(r1,<span class="string">'b*'</span>,markersize=<span class="number">4</span>)</span><br><span class="line">plt.ylabel(<span class="string">'interest rate r'</span>,fontsize = <span class="number">20</span>)</span><br><span class="line">plt.legend(handles=[l1, l2], labels=[<span class="string">'Euler'</span>, <span class="string">'Milstein'</span>], fontsize = <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>Visualizing the results:</p>
<p><img src="https://img-blog.csdnimg.cn/20200303225854819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZWNhbg==,size_16,color_FFFFFF,t_70" alt="Monte Carlo Simulation"></p>
<h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p>CIR Modeling of Interest Rates</p>
<p><a href="http://lnu.diva-portal.org/smash/get/diva2:1270329/FULLTEXT01.pdf" target="_blank" rel="noopener">http://lnu.diva-portal.org/smash/get/diva2:1270329/FULLTEXT01.pdf</a></p>
<p>Enlightened reading material</p>
<p><em>Higham, D. J. (2001). An algorithmic introduction to numerical simulation of stochastic differential equations. SIAM review, 43(3), 525-546.</em></p>
<p>Ito-Taylor Expansion</p>
<p><a href="https://www.math.nyu.edu/~cai/Courses/Derivatives/compfin_lecture_5.pdf" target="_blank" rel="noopener">https://www.math.nyu.edu/~cai/Courses/Derivatives/compfin_lecture_5.pdf</a></p>
<p>结束语：我做笔记博客主要有三个目的：1. 在疫情长假期间，闲下来有时间思考人生（睡觉），深刻意识到自己一直在追求一些浮名薄利，一味想高屋建瓴导致一事无成，却忽略了最根本的积累，因而通过博客逼迫自己把每一个小的问题搞清楚并记录下来。2. 虽然生活和事业收获了很多的帮助，但是科研和学习主要靠自己摸索（仰视巨人的肩膀然后脑补），难免有一些异想天开的不足，希望各路大神路过能留下足迹，帮我纠正，让我进步。3. 希望我的行为能帮助到同行人，也算是一点贡献，不枉此生。</p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Simulation</tag>
      </tags>
  </entry>
  <entry>
    <title>Weibull Distribution_MLE_with_Newton_Ranpson_Method</title>
    <url>/2020/02/21/Distribution-MLE-with-Newton-Ranpson-Method/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Censored-Weibull-Distribution-最大似然估计-（结合牛顿法求解）"><a href="#Censored-Weibull-Distribution-最大似然估计-（结合牛顿法求解）" class="headerlink" title="Censored Weibull Distribution 最大似然估计 （结合牛顿法求解）"></a>Censored Weibull Distribution 最大似然估计 （结合牛顿法求解）</h1><p><em>前言：写这篇博客是因为我前几天偶然读到一篇很有意思的文章， 然后想用自己的实验数据测试一下其分布情况，本以外是一个很简单的工作，但再简单的工作也需要不断的更新学习。在学习过程中，我发现已经有很多博文详述了Weibull分布的应用和意义，然而对于如何进行参数估计的问题，却缺乏更加详细的记录文档。于是无聊而又不务正业的Shecan稍微探索了一下，并把笔记分享给大家。如有错误或者疑问，请给Shecan留言。</em></p>
<a id="more"></a>
<p>Weibull 分布函数 CDF：</p>
<script type="math/tex; mode=display">
F(x) = 1 - e^{-(\frac{x}{\beta})^{\alpha}}\tag{1}</script><p>这里 $\beta$ 表示 Scale Parameter, $\alpha$ 表示 Shape Parameter。</p>
<p>分布密度 PDF：</p>
<script type="math/tex; mode=display">
f\left( x\right) =\frac {\alpha } {x}\gamma ^{\alpha }e^{-\gamma ^{\alpha}}\tag{2}</script><p>其中 </p>
<script type="math/tex; mode=display">
\gamma = \frac{x}{\beta}</script><p>censored 似然函数的定义：</p>
<script type="math/tex; mode=display">
L=\prod _{i=1}^{n}\left( f\left( x_i\right) \right) ^{\delta_i}\left( 1-F\left( x_{i}\right) \right) ^{1-\delta_{i}}\tag{3}</script><p>其中</p>
<script type="math/tex; mode=display">
\delta _{i}=\begin{cases} 1,\,x\leq threshold\\ 0,\,x>threshold\end{cases}</script><p>把（1），（2）带入（3）两边求对数，并简化求得对数似然函数：</p>
<script type="math/tex; mode=display">
1og_L=\sum _{i=1}^{n}\left( - \gamma _{i}^{\alpha }+\delta_{i}\alpha ln\gamma _{i}+\delta\ln \frac {\alpha } {x_{i}}\right)\tag{4}</script><p>其中$\alpha$，$\beta$, 可以通过最大化似然函数求得，对（4）求一阶导数</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^{n}\gamma_i^\alpha-\delta_i=0,\tag{5}\\
\sum _{i=1}^{n}\left( -\gamma _{i}^{\alpha }\ln \gamma _{i}+\delta_i\ln \gamma _{i}+\frac {\delta_i} {\alpha }\right) =0.\tag{6}
\end{align}</script><p>（5），（6）是关于$\alpha,\,\beta$ 的外生解，无法求出其解析解，因而需要求解以上两个非线性方程组的数值解。求解非线性方程组数值解的方法有很多，比如非线性最小二乘法，Broyden方法等等，但是我们遵循简单即有效的原则，尝试最为简单的Newton-Rapson解的搜索方法。首先，简化（5）得</p>
<script type="math/tex; mode=display">
\beta =\left( \frac {\sum_{i}^{n}x_{i}^{\alpha }} {\sum_{i}^{n}\delta_{i}}\right) ^{\frac {1} {\alpha }}\tag{7}</script><p>因此，我们只需要通过（6）求解 $\alpha$, 假设</p>
<script type="math/tex; mode=display">
h(\alpha)=\sum _{i=1}^{n}\left( -\gamma _{i}^{\alpha }\ln \gamma _{i}+\delta_i\ln \gamma _{i}+\frac {\delta_i} {\alpha }\right)\tag{8}</script><p>其中</p>
<script type="math/tex; mode=display">
\gamma _{i}=\frac {x_{i}} {\beta }=x_i\left( \frac {\sum x_{i}^{\alpha}}{n}\right)^{-\frac {1} {\alpha }}</script><p>and</p>
<script type="math/tex; mode=display">
\begin{align}
\gamma _{i}^{\alpha }&=x_{i}^{\alpha}\cdot \frac {n} {\sum x_{i}^\alpha} \tag{9}\\
\ln \gamma _{i}&=\ln x_i-\frac {1} {\alpha }\cdot \frac {\sum x_{i}^{\alpha }} {n} \tag{10}
\end{align}</script><p>这里的 $n=\sum \delta_i$ 代表 failed number。</p>
<p>（9）和 （10）代入（8），即得</p>
<script type="math/tex; mode=display">
h\left( \alpha \right) =n\left( -\frac {\Sigma x ^{\alpha }_iln x_{i}} {\sum x_{i}^{\alpha }}+\frac {1} {\alpha }+\frac {1} {n}\Sigma \delta_i\ln x_{i}\right)\tag{10}</script><p>求导可得</p>
<script type="math/tex; mode=display">
h'\left( \alpha \right) =n\left( -\frac {1} {\alpha^2}+\frac {\sum x_{i}^{\alpha }\left( ln x_{i}\right) ^{\alpha }} {\sum x_{i}^{\alpha }}-\frac {\left( \sum x_{i}^{\alpha }\ln x_{i}\right) ^{2}} {\left( \sum x_i^{\alpha }\right) ^{2}}\right)</script><p>因而，我们通过牛顿法迭代搜索非线性方程 $h(\alpha)=0$ 的解。</p>
<script type="math/tex; mode=display">
\alpha_{k+1}=\alpha_{k}-\frac{h\left(\alpha_{k}\right)}{h^{\prime}\left(\alpha_{k}\right)}\tag{11}</script><p>求解出 $\alpha$ 后，通过 （7）即可求解 $\beta$ 。</p>
<h3 id="Weibull-MLE-程序实现："><a href="#Weibull-MLE-程序实现：" class="headerlink" title="Weibull MLE 程序实现："></a>Weibull MLE 程序实现：</h3><p>推导过程写完了，怎么用程序实现呢？从多年来失败的研究经验Shecan总结了一个道理：不要重复造轮子。（其实学习的时候重复造下轮子也有好处。） Shecan 发现Python有一个比较有意思的Package。 叫做Weibull，基本可以满足你大部分的研究需求。具体怎么使用，请参考下面的参考文献。但是，有时候我们依旧需要对模型进行改进，比如说两参数的Weibull分布改成三参数的Weibull分布。为满足这种需求，Shecan找出了Weibull Package MLE部分的源程序，并改写成了面向过程的编程方式，具体如下：</p>
<p>你可以把下面的代码复制到 Jupyter Notebook：</p>
<p>注明：程序来自于Weibull Package: </p>
<p><a href="Weibull Package Doc">https://weibull.readthedocs.io/en/latest/examples.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<p>测试数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fail_times = [ <span class="number">9402.7</span>, <span class="number">6082.4</span>, <span class="number">13367.2</span>, <span class="number">10644.6</span>, <span class="number">8632.0</span>, <span class="number">3043.4</span>, <span class="number">1034.5</span>, <span class="number">2550.9</span>, <span class="number">2550.9</span>, <span class="number">3637.1</span>]</span><br><span class="line">suspended = [<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>,<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>]</span><br><span class="line">data = pd.DataFrame(&#123;<span class="string">'data'</span>: fail_times, <span class="string">'susp'</span>:suspended&#125;)</span><br></pre></td></tr></table></figure>
<p>MLE Calibration: 通过以上的推导过程可以很容易的读懂这段代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filter the failed samples and extract values</span></span><br><span class="line">df_failed = data[data.susp == <span class="literal">False</span>].copy() </span><br><span class="line">dtf_failed = df_failed[<span class="string">"data"</span>].values</span><br><span class="line">df_failed[<span class="string">"ln_x_div_r"</span>] = df_failed.apply(<span class="keyword">lambda</span> s: np.log(s[<span class="string">'data'</span>])/len(df_failed), axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># extract data of all the values</span></span><br><span class="line">dtf_all = data[<span class="string">'data'</span>].values</span><br><span class="line"><span class="comment"># use Newton-Rhapson method for estimating the shape parameter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># give initial value for the shape paramter:</span></span><br><span class="line">shape = (((<span class="number">6.0</span> / np.pi ** <span class="number">2</span>)</span><br><span class="line">            * (np.sum(np.log(dtf_all) ** <span class="number">2</span>)</span><br><span class="line">            - ((np.sum(np.log(dtf_all))) ** <span class="number">2</span>) / dtf_all.size))</span><br><span class="line">            / (dtf_all.size - <span class="number">1</span>)) ** <span class="number">-0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10 iterations of the newton-rhapson method</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    a = np.sum(np.log(dtf_failed) * <span class="number">1.0</span>) / dtf_failed.size</span><br><span class="line">    b = np.sum(dtf_all ** shape)</span><br><span class="line">    c = np.sum((dtf_all ** shape) * np.log(dtf_all))</span><br><span class="line">    h = np.sum((dtf_all ** shape) * (np.log(dtf_all)) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    shape = shape + (a + (<span class="number">1.0</span> / shape) - (c / b)) / ((<span class="number">1.0</span> / shape ** <span class="number">2</span>) + ((b * h) - c ** <span class="number">2</span>) / b ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">shape = max(shape, <span class="number">0.005</span>)</span><br><span class="line">scale = (np.sum((dtf_all ** shape) / len(df_failed))) ** (<span class="number">1</span> / shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print the results</span></span><br><span class="line">print(shape,scale)</span><br></pre></td></tr></table></figure>
<p><strong>题外话：小时候老师教育我们如果要成为一个成功的人，头悬梁，锥刺骨，卧薪尝胆，这些典故都很励志。可是长大后发现了一个残酷的真相，成功人士万里挑一，而千千万万的普通人虽然没有那么成功，却也在以一己之力改变世界。比如说战疫前线的医生和护士们，比如说用自己的才能为这次疫情做贡献的各路神仙。经历了这些事，这些人，Shecan开始反思，与其教育自己的孩子成为一个成功的人，不如教育他们尽一己之力做一个对社会有贡献的人，或许这样的人生会更自信，更快乐，并获得更高的自我效能感。这也算是Shecan开始做笔记，并分享笔记的原因吧。</strong></p>
]]></content>
      <categories>
        <category>Algorithm Study</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Calibration</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab Plot with User Defined Color</title>
    <url>/2020/02/21/MATLAB%20Plot%20user%20defined%20color/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MATLAB-Plot-如何自定义颜色"><a href="#MATLAB-Plot-如何自定义颜色" class="headerlink" title="MATLAB Plot 如何自定义颜色"></a>MATLAB Plot 如何自定义颜色</h2><p>Tip: Matlab 作图时最好保存成fig格式，便于以后修改。</p>
<p>写论文是一个漫长的过程，成文后最重要的一个问题就是如何让自己的论文排版和插图更加的好看，让枯燥的论文有一点生动的色彩。这里记录我在写论文时的困惑和一些小小的技巧。</p>
<a id="more"></a>
<p>以下面这个图为例：<br><img src="https://img-blog.csdnimg.cn/20200113001358688.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoZWNhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><em>X = linspace(0,5,51);<br>Y1 = sin(X);<br>Y2 = cos(0.5</em>X);<br>Z = 2<em>Y1+0.3</em>Y2;<br>plot(X,Y1,’color’,[1,0,1],’Marker’,’<em>‘);hold on;<br>plot(X,Y2,’color’,[0.9,0.5,0.5],’LineWidth’,2);hold on;<br>plot(X,Z,’color’,[0.9,1,0.7],’Marker’,’diamond’,’MarkerEdgeColor’,’r’)<br>xlabel(‘x’,’FontSize’,15)<br>ylabel(‘y’,’FontSize’,15)<br>title(‘Customized the plot color in Matlab’,’Color’,[0.7,0,1])<br>方括号中间的三个数字表示的三原色的比例，配色标准可以参考：Matlab配色<br>Plot的基本命令： plot(x,y,’property name’,property value)<br>如果不记得property name怎么办？不用担心，Matlab会给你提示，总是可以找到自己想要的。<br>如何画出渐变图？<br>当然是写个for循环就可以了。</em><br><img src="https://img-blog.csdnimg.cn/20200113001422904.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoZWNhbg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><em>clear all<br>hold off<br>X = linspace(-pi/2,pi/2,10)<br>figure(‘Color’,[0.94,1,0.94])<br>for i = 1:20<br>        plot(X,(-1)^(i)</em>i<em>X,’color’,[1-i</em>0.05,0+i<em>0.03,1-i</em>0.01],’LineWidth’,0.5+0.05<em>i);<br>        hold on;<br>end<br>axis([-pi/2,pi/2,-35,35])</em></p>
]]></content>
      <categories>
        <category>Coding Tips</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab 高维矩阵与向量的点乘 （Permute）</title>
    <url>/2020/02/21/Matlab%20%E9%AB%98%E7%BB%B4%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%90%91%E9%87%8F%E7%9A%84%E7%82%B9%E4%B9%98%20%EF%BC%88Permute%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Matlab-高维矩阵与向量的点乘-（Permute）"><a href="#Matlab-高维矩阵与向量的点乘-（Permute）" class="headerlink" title="Matlab 高维矩阵与向量的点乘 （Permute）"></a>Matlab 高维矩阵与向量的点乘 （Permute）</h1><p>今天遇到一个问题，如何用一个n维的向量点乘一个$m\times k\times n$ 的矩阵， 并避免用循环。Matlab矩阵实验室名不虚传，通过permute这个命令可以有效解决这个问题。因此记录下来，以备不时之需 （几年前遇到过同样的问题，但是没做笔记，所以这次一定要记下来）。</p>
<a id="more"></a>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; <span class="comment">% 这里需要注意Matlab是按列存储的；</span></span><br><span class="line">test = <span class="built_in">repmat</span>(a,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>); <span class="comment">% 把向量a复制成一个3*3*3的矩阵；</span></span><br></pre></td></tr></table></figure>
<p> 查看test矩阵</p>
<script type="math/tex; mode=display">
test\left( :,: ,1\right) =\left[ \begin{matrix} 1& 2& 3\\ 1& 2& 3\\ 1& 2& 3\end{matrix} \right],test\left( :,: ,2\right) =\left[ \begin{matrix} 1& 2& 3\\ 1& 2& 3\\ 1& 2& 3\end{matrix} \right], test\left( :,: ,3\right) =\left[ \begin{matrix} 1& 2& 3\\ 1& 2& 3\\ 1& 2& 3\end{matrix} \right]</script><p>我想要的结果</p>
<script type="math/tex; mode=display">
testz\left( :,: ,1\right) =\left[ \begin{matrix} 1& 2& 3\\ 1& 2& 3\\ 1& 2& 3\end{matrix} \right],testz\left( :,: ,2\right) =\left[ \begin{matrix} 10& 20& 30\\ 10& 20& 30\\ 10& 20& 30\end{matrix} \right], testz\left( :,: ,3\right) =\left[ \begin{matrix} 100& 200& 300\\ 100& 200& 300\\ 100& 200& 300\end{matrix} \right]</script><p>实现的方法</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">z = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>]; <span class="comment">% 定义一个向量z</span></span><br><span class="line">test_z = <span class="built_in">permute</span>(z,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])； <span class="comment">%permute 用于求三维矩阵的转置</span></span><br></pre></td></tr></table></figure>
<p>对于二维矩阵的转置，我们通常用 ’ ；但是对于高维向量，需要使用permute, 上面的命令表示第二个维度的数据（列）放到第三个维度，所以我们猜测test_z会是一个 $1\times 1\times 3$的这么一个矩阵，查看test_z的结果</p>
<script type="math/tex; mode=display">
test_z\left( :,: ,1\right) = 1；test_z\left( :,: ,2\right) = 10； test_z\left( :,: ,3\right)=100；</script><p>如你所愿，最后我们有</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">testz = test_z.*test; <span class="comment">% 得到我想要的效果</span></span><br></pre></td></tr></table></figure>
<p>注意，如果是对行(第一维度)点乘，只需要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">z.* test</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
testz\left( :,: ,1\right) =\left[ \begin{matrix} 1& 2& 3\\ 10& 20& 30\\ 100& 200& 300\end{matrix} \right],testz\left( :,: ,2\right) =\left[ \begin{matrix} 1& 2& 3\\ 10& 20& 30\\ 100& 200& 300\end{matrix} \right], testz\left( :,: ,3\right) =\left[ \begin{matrix} 1& 2& 3\\ 10& 20& 30\\ 100& 200& 300\end{matrix} \right]</script><p>如果对列进行点乘，需要进行行列转置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">z&#39;.*test</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
testz\left( :,: ,1\right) =\left[ \begin{matrix} 1& 20& 300\\ 1& 20& 300\\ 1& 20& 300\end{matrix} \right],testz\left( :,: ,2\right) =\left[ \begin{matrix} 1& 20& 300\\ 1& 20& 300\\ 1& 20& 300\end{matrix} \right], testz\left( :,: ,3\right) =\left[ \begin{matrix} 1& 20& 300\\ 1& 20& 300\\ 1& 20& 300\end{matrix} \right]</script><p>虽然很简单，但是这么简单的问题我也是花了大概二十分钟去思考，再花二十分钟做笔记，希望以后可以帮助自己和有缘人。能遇到同样的变态问题，还看到我的博客，说明都是猿粪啊，既然这么有缘，你舍得不给我点赞吗？哈哈</p>
]]></content>
      <categories>
        <category>Coding Tips</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Cheatsheet</title>
    <url>/2020/02/21/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="hexo-debug"><a href="#hexo-debug" class="headerlink" title="hexo debug"></a>hexo debug</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo debug</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Coding Tips</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
